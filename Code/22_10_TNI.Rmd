---
title: "Spillover Analysis"
author: "Yingjie Li"
date: "2021-03-01 (Updated: 2021-03-04)"
output: pdf_document
editor_options: 
  chunk_output_type: console
---


  This script aims to 
  
  1. Read the combined EORA indicator data (4 years data in one table), and calculate `net imports` for each indicator, each year, and each country. 
  
  2. Calculate `spillover score` and `spillover index`, according to SDSN's approach. 
  
  
# Set up
```{r Paths and packages}
knitr::opts_chunk$set(echo = TRUE)

### To clear your environment 
# remove(list = ls())

### set work dir
path <- rstudioapi::getSourceEditorContext()$path
dir  <- dirname(rstudioapi::getSourceEditorContext()$path); dir
setwd(dir)
setwd('..') # set directory by one folder up
getwd()

dir.eora         <- './Data/data_02_intermediate/dt02_flows/eora/'
dir.eora_cleaned <- './Data/data_02_intermediate/dt02_flows/eora_cleaned/'
dir.fig          <- './Data/Figure/'

dir.arm          <- './Data/data_01_raw/Arm trade_Peacekeeping/SIPRI Arms trade/'
dir.traffick     <- './Data/data_01_raw/Human trafficking/'

### packages
source('./Code/_package list.R')
library(stringr)
```



```{r Theme and font}


### plot settings
unit_ns    <- 'cm'
width_1col <- 8.8   ## 1-column
width_2col <- 18    ## 2-column
font       <- 'sans'     ## "TT Arial"
font_size  <- 8          ##  Nature Sustainability: max = 7; min = 5

theme_set(theme_bw(base_size = font_size))

theme_ns <- 
  theme_bw()+
  theme(
    # axis.title =element_blank(),
    # axis.text  =element_blank(),
    # axis.ticks =element_blank(),
    # panel.background = element_rect(fill = NA),
    panel.grid.major.x = element_blank(),
    # panel.grid.major = element_blank(),
    # panel.grid.minor = element_line(colour = "red", size = 1),
    legend.background = element_rect(fill="transparent"),
    legend.key.size = unit(0.15,"cm"),
    text = element_text(size=font_size)
        )
```


```{r Ancillary data}
load('./Data/Ancillary_Data_ISO3code_shp.RData') ## iso_eora, pop, gdp, shp, grp

### extended country-iso3 pair list for matching
load('./Data/Ancillary_Data_iso_eora_ex.RData')  ## ## iso_eora_ex
```


```{r Ancillary data 2 - Eora cleaned format}
### To filter countries only listed in Eora
### - use the Eora data as the template 
temp <- readxl::read_excel(paste0('./Data/data_02_intermediate/dt02_flows/eora_cleaned/', 'CO2.xlsx')) 
temp_eora <- temp %>%
  gather(key = to, value = value, 4:ncol(.)) %>%
  dplyr::select(-value) %>% # -ctr, 
  as.data.frame()
nrow(temp_eora) ## 142884 = 189 * 189 * 4 years

f <- paste0('./Data/data_02_intermediate/dt02_flows/', 'template_eora.RData')
# save(temp_eora, file = f)
load(f)
```





#  Data 
## Get a sense of the MRIO data
  Water use MRIO table as an example
```{r}
getwd()
xls <- paste0(dir.eora_cleaned, "Water.xlsx")
df <- readxl::read_excel(path = xls)


### total water use for each country ?= row sum in IO table?
### 1. data from IO table
test_rowsum <- df %>% 
  as.data.frame() %>%
  dplyr::mutate(total_ex = rowSums(.[4:ncol(.)])) %>%
  dplyr::select(year, ctr, iso3, total_ex) %>%
  dplyr::mutate(total_ex_10e9 = total_ex/10^9,
                total_ex_10e9 = round(total_ex_10e9, digits = 2)) %>%
  dplyr::filter(year == 2015) %>%
  arrange(ctr)

### 2. data from FAO aquastat 
test_water_fao <- readxl::read_excel(
  path = './Data/data_01_raw/FAO_aquastat/aquastat_Total water withdrawal_fao_2015.xlsx', skip = 1, 
  col_names = c('item', 'ctr', 'year', 'value'))  %>%
  dplyr::filter(!is.na(item), !is.na(ctr)) %>%
  dplyr::mutate(value = round(value, digits = 2)) %>%
  arrange(ctr) %>%
  merge(x = ., y = iso_eora, by.x = 'ctr', by.y = 'Row', all.x = T)%>%
  arrange(!is.na(iso3_eora), iso3_eora)

### 3. compare these two
test_compare <- merge(x = test_rowsum, y = test_water_fao, by.x = 'iso3', by.y = 'iso3_eora', all = T) %>%
  dplyr::select(iso3, total_ex_10e9, value, everything())


### 4. plot
lm_eqn <- function(df){
    m <- lm(y ~ x, df);
    eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
         list(a = format(unname(coef(m)[1]), digits = 2),
              b = format(unname(coef(m)[2]), digits = 2),
             r2 = format(summary(m)$r.squared, digits = 3)))
    as.character(as.expression(eq));
}

test_df <- test_compare %>%
  dplyr::mutate(x = total_ex_10e9, y = value) 

test_df %>%
  ggplot(aes(x = log(total_ex_10e9), y = log(value))) +
  geom_point() +
  geom_smooth() +
  geom_text(x = -2, y = 5, label = lm_eqn(test_df), parse = TRUE)


#### 5. the conclusion: very likely they are the same number, but because of not all of the countries are included in Eora, so the row sum is slightly smaller than data from FAO statistics. 



### max and min
df_l <- df %>% gather(key = 'ctr_col', value = 'value', 4:ncol(.))
max <- max(df_l$value, na.rm = TRUE); max
min <- min(df_l$value, na.rm = TRUE); min

df_l_norm <- df_l %>%
  dplyr::mutate(value_norm = (value - min)/(max - min))

```






# Analysis
  Here, we use the approach by Sachs et al (SDSN) Reports. That is, looking at the spillovers only, but not the impacts on SDG scores. They took `footprint flows per capita` as the indicator, here, we use the actual amount of `footprint flows` as the spillover indicator.
  
  **Spillover Score**: the normalized score of each spillover, which measured by "net imports". 
  Scores should be interpreted in the same way as the SDG Index score: from 
    - `0   (poor performance`, i.e., significant negative spillovers) to 
    - `100 (good performance`, i.e., no significant negative spillovers). 
    
  **Spillover Index**: a consolidated (or composite) score of multiple spillovers (Sachs et al, 2020) 
    - Sachs et al only measured the Index, but did not report the score by Goal.
    
  
  Per discussion with Jack Liu, we plan to use *metacoupling impact score*, which is a more inclusive concept that characterize the interactions among not only distant countries and nearby countries. 
    


## Function for calculate "net import" and "normalized score" 
  Normalization function needs to consider which is positive indicator and which is negative indicator. For example, ODA is an example of a positive spillover. 
  
```{r}

### function 1 ----- (not used)
source('./Code/func_net_import.R')



### function 2 -------------------------------------------------------------------------------------
source('./Code/func_net_import_direction.R')


### test code ---
# t <- data.frame(id = seq(1:100), value = sample(x = seq(0,1, 0.05), size = 100, replace = T))
# t[5, 2] <- NA
# t %>% arrange(desc(value)) %>% top_frac(.05)
# b <- t$value %>% unlist() %>% na.omit() 
# length(b) 
# t$value %>% unlist() %>% na.omit() %>% sort(decreasing = T) %>% dplyr::nth(n = length(.)*0.025)

```





## Spillover Score 

### Way 1 ----------- NOT USED

  
#### 1. Non-SHDB spillover

```{r eval=FALSE, include=FALSE}
xls.ls <- list.files(path = dir.eora_cleaned, pattern = 'xlsx$', full.names = T); xls.ls


### Get the list of files for SHDB data, and remove them from the whole list
xls.ls.SHDB <- str_subset(xls.ls, pattern="SHDB")
xls.ls.other<- setdiff(xls.ls, xls.ls.SHDB); xls.ls.other

cat('There are', xls.ls.SHDB %>% length(),  'SHDB FT indicators') 
cat('There are', xls.ls.other %>% length(), 'Non-SHDB FT indicators') 



### put all spillover indicators in one table
net_imports <- data.frame()

for (xls in xls.ls.other) {
  print(xls)
  df <- readxl::read_excel(path = xls)
  
  ## get the indicator name
  ind <- gsub('.xlsx', '', basename(xls)); print(ind)

  ### check rows and columns
  # print(nrow(df)); print(ncol(df))

  ### max and min
  # df_l <- df %>% gather(key = 'ctr_col', value = 'value', 4:ncol(.))
  # # str(df_l)
  # max <- max(df_l$value, na.rm = TRUE); max
  # min <- min(df_l$value, na.rm = TRUE); min
  
  net_in <- func_net_import(df = df)
  net_imports <- rbind(net_imports, cbind(ind = ind, net_in))

}


### check the data
unique(net_imports$year) %>% sort()
unique(net_imports$ind) %>% sort()
length(unique(net_imports$ind))


net_imports1 <- net_imports
```


   An individual example
```{r eval=FALSE, include=FALSE}

### forest -----
xls <- list.files(path = dir.eora_cleaned, pattern = '^Landuse_forest', full.names = T); xls
df <- readxl::read_excel(path = xls) 

df_flow <- df %>%
  dplyr::filter(year == 2015) %>%
  gather(key = 'Target', value = 'Weight', 4:ncol(.)) %>%
  dplyr::rename(Source = iso3) %>%
  
  ## remove domestic flows -------------------
  dplyr::filter(Source != Target) %>%
  arrange(desc(Weight)) %>%
  
  ## look at the top 10 flows
  head(10) %>%
  as.data.frame()
```


#### 2. SHDB spillover
```{r eval=FALSE, include=FALSE}
### put all spillover indicators in one table
net_imports <- data.frame()

for (xls in xls.ls.SHDB) {
  # print(xls)
  df <- readxl::read_excel(path = xls) %>%
    dplyr::mutate(year = as.numeric(year)) %>%
    # dplyr::filter(year < 2019) %>%        ### remove years > 2015 in SHDB
    as.data.frame()
  
  ## get the indicator name
  ind <- gsub('.xlsx', '', basename(xls)); print(ind)
  
  net_in <- func_net_import(df = df)
  net_imports <- rbind(net_imports, cbind(ind = ind, net_in))

}


### check the data
names(net_imports)
unique(net_imports$year) %>% sort()
unique(net_imports$ind) %>% sort()
length(unique(net_imports$ind))

net_imports2 <- net_imports
dfSummary(net_imports2)


### 2000, 2014, 2015, 2019 --> 2000, 2005, 2010, 2015 ?
net_imports2_revise <- net_imports2 %>% 
  gather(key = 'vars', value = 'value', total_ex:score) %>%
  spread(key = year, value = value) %>%
  ### we set data in 2000 and 2005 as NA; we use data for 2014 as a substitute of 2010
  dplyr::mutate(`2005` = `2000`, 
                `2010` = `2014`) %>%
  ### then we remove data in 2014 and 2019, and reformat this data to its original format
  dplyr::select(-`2014`, -`2019`) %>%
  gather(key = 'year', value = 'value', 4:ncol(.)) %>%
  spread(key = vars, value = value) %>%
  ### align the column names 
  dplyr::select(names(net_imports1))
  
```


#### 3. Combine all data
  We may call this net imports data `outsourced footprints`. (OR displaced footprints?)
  
```{r eval=FALSE, include=FALSE}
# id_fig <- 5
# 
# net_imports_fromAll <- rbind(net_imports1, net_imports2_revise, net_imports3, net_imports4, net_imports5) %>%
#   arrange(ind, iso3, year) %>%
#   as.data.frame()
```
  
  



### Way 2 ---------> UPDATE!?

  Only indicators with decided *direction* were included in the calculation, while assign *NA* to those with un-decided direction. 
  - Need to update the `direction` table!
  
```{r }

### get the name list of all the spillovers and manually add `direction` info for further normalizing the values

xls.ls <- list.files(path = dir.eora_cleaned, pattern = 'xlsx$', full.names = T); xls.ls

spillover_name_list <- data.frame(ind = gsub('.xlsx', '', basename(xls.ls))) %>%
  # dplyr::mutate(shdb = str_detect(ind, pattern="SHDB")) %>%
  dplyr::mutate(direction = '') %>%  ## to determine if it is positive or negative impact
  as.data.frame()
# writexl::write_xlsx(x = spillover_name_list, path = './Data/data_02_intermediate/dt02_flows/spillover_name_list.xlsx')


### --> manually add `direction`
### ...  
###
### ...


### loop the normalization based on direction ------------------------------------------------------
xls <- paste0('./Data/data_02_intermediate/dt02_flows/', "spillover_name_list_directions.xlsx"); xls
direction <- readxl::read_excel(path = xls) %>%
  dplyr::filter(!is.na(ind) & !is.na(direction))

### put all spillover indicators in one table 
net_imports <- data.frame()

for (i in 1:nrow(direction)) {
  # print(i)
  ind <- direction[i, 1] %>% unlist() %>% paste(sep = '', collapse = ''); 
  drt <- direction[i, 2] %>% unlist() %>% paste(sep = '', collapse = '') %>% as.numeric()
  print(ind)
  print(drt)
  
  xls <- paste0(dir.eora_cleaned, ind, '.xlsx'); print(xls)
  df  <- readxl::read_excel(path = xls)

  ### check rows and columns
  # print(nrow(df)); print(ncol(df))

  ### max and min
  # df_l <- df %>% gather(key = 'ctr_col', value = 'value', 4:ncol(.))
  # # str(df_l)
  # max <- max(df_l$value, na.rm = TRUE); max
  # min <- min(df_l$value, na.rm = TRUE); min
  
  net_in <- func_net_import_direction(df = df, direction = drt, frac = 0.025)
  net_imports <- rbind(net_imports, cbind(ind = ind, net_in))
  
}


net_imports_fromAll <- net_imports
```

  

#### - result summary
```{r}
net_imports_fromAll$scenario <- 'fromAll'

dfSummary(net_imports_fromAll)

length(unique(net_imports_fromAll$iso3))
unique(net_imports_fromAll$year)

## shdb do not have data in 2000, 2005, 2010
net_imports_fromAll_check <- net_imports_fromAll %>%
  dplyr::filter(!year %in% c(2000, 2005, 2010, 2015)) %>%
  dplyr::distinct(ind, year, .keep_all = T)

### save the data
n_ft_ind <- length(unique(net_imports_fromAll$ind)); n_ft_ind
fname <- paste0(dir.eora_cleaned, 'net_imports_fromAll_', n_ft_ind, '.RData'); fname
save(net_imports_fromAll, file = fname)
```





## Spillover Index
```{r}

### load data
ls_f <- list.files(path = dir.eora_cleaned, pattern = '^net_imports_fromAll_', full.names = T); ls_f
tail(ls_f, n = 1)
load(tail(ls_f, n = 1)) ## load the latest data


### spillover normalized score for each indicator
spillover_norm <- net_imports_fromAll %>%
  dplyr::select(ind, iso3, year, score) %>%
  spread(key = 'ind', value = 'score')

spillover_norm <- spillover_norm %>% select_if(~any(!is.na(.)))

# dfSummary(spillover_norm)


### score for the aggregated index (i.e., the average value of all indicators) ---------------------
spillover_index <- net_imports_fromAll %>%
  ungroup() %>% as.data.frame() %>%
  dplyr::filter(year %in% c(2000, 2005, 2010, 2015)) %>%
  dplyr::select(ind, iso3, year, score) %>%
  group_by(iso3, year) %>%
  dplyr::summarise(index = mean(score, na.rm = T),
                   non_na_count = sum(!is.na(score))) %>%
  arrange(iso3, year)

hist(spillover_index$index)



### look at social and environmental aspect separately ---------------------------------------------
spillover_index_se <- net_imports_fromAll %>%
  ungroup() %>% as.data.frame() %>%
  dplyr::filter(year %in% c(2000, 2005, 2010, 2015)) %>%
  dplyr::select(ind, iso3, year, score) %>%
  dplyr::mutate(se = ifelse(str_detect(ind, 'SHDB'), 's', 'e')) %>%
  group_by(iso3, year, se) %>%
  dplyr::summarise(index = mean(score, na.rm = T)) %>%
  arrange(iso3, year)

hist(spillover_index_se$index)
```





### Map
```{r - index}
### map of spillover Index score ---------------------------------------------------------
### 
spillover_index_shp <- shp %>%
  merge(x = ., y = spillover_index, by.x = 'iso_a3', by.y = 'iso3', all.x = T) %>%
  arrange(!is.na(year))
# str(score_index_shp)

### to check if all the spillover data has been matched with the shp
spillover_index_shp_match_check <- spillover_index %>%
  dplyr::filter(year == 2015) %>%
  merge(y = shp, x = ., by.y = 'iso_a3', by.x = 'iso3', all.x = T) 
nrow(spillover_index_shp_match_check) ## ROW was not included here. 


### 4 years map
map4 <- spillover_index_shp %>%
  dplyr::filter(!is.na(year)) %>%
  ggplot()+
  geom_sf(aes(fill = index), color='gray80', size = 0.1) +
  scale_fill_distiller(palette = "Spectral", direction = -1, na.value = 'black', name = 'Impact\nIndex') +
  # theme(legend.position = c(0.05, 0.3)) +
  facet_wrap(.~year) +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank())
map4
timestamp <- format(Sys.time(), "%Y%m%d") ## %H%M%S
fname <- paste0(dir.fig, 'spillover/', 'map_spillover_index', '_', timestamp, '.jpg'); fname
ggsave(filename = fname, plot = map4, width = width_2col, height = width_2col/2, units = unit_ns, dpi = 300)



### 1 year map for 2015 only -----------------------------
map1 <- spillover_index_shp %>%
  dplyr::filter(!is.na(year)) %>%
  dplyr::filter(year == 2015) %>%
  ggplot()+
  geom_sf(aes(fill = index), color='gray80', size = 0.1) +
  scale_fill_distiller(palette = "Oranges", direction = 1, na.value = 'black', name = 'Impact\nIndex') +
  # scale_fill_viridis(direction = -1, option = 'C', discrete = F, name = 'Impact\nIndex') +
  theme(legend.position = c(0.1, 0.35)) +
  theme(axis.text.x=element_blank(), panel.grid = element_blank(),
        panel.border = element_blank(),
        plot.margin = unit(c(0,0,0,0), "pt"), ## 0,0,0,0
        axis.ticks.x=element_blank())
map1
fname <- paste0(dir.fig, 'spillover/', 'map_spillover_index_2015.jpg'); fname
ggsave(filename = fname, plot = map1, width = width_2col, height = width_2col*2.8/7, units = unit_ns, dpi = 300)

```




```{r - index rank}

### which generate the most impacts and which were most impacted? 
spillover_index_top_bottom <- spillover_index_shp %>%
  st_drop_geometry() %>%
  dplyr::filter(year == 2015) %>%
  arrange(index) %>%
  
  ## remove countries with very few available data ---------------
  dplyr::filter(non_na_count > 5) %>%
  
  ## to get the top 10 and bottom 10 -----------------------------
  dplyr::filter(dense_rank(index) <= 10 | dense_rank(desc(index)) <= 10) %>%
  ### --> self-defined 2 group: high, low income
  # dplyr::mutate(group = case_when(
  #   str_detect(income_grp, 'High|Upper') ~ "high income", ## high or upper-middle
  #   str_detect(income_grp, 'Low') ~ "low income",         ## low or low-middle
  #   TRUE ~ '0')) %>%
  ### --> more groups based on World Band classification
  dplyr::mutate(
    group = tm::removeNumbers(income_grp),
    group = gsub(":.*", "", group),
    group = gsub("(?!\\:)[[:punct:]]", "", group, perl=TRUE),
    group = stringr::str_squish(group),
    group = factor(x = group, levels = c("High income", "Upper middle income", "Lower middle income", "Low income"))) %>%
  dplyr::mutate(name = ifelse(iso_a3 == 'USA', 'United States', name)) %>% ## long name to short 
  as.data.frame()


spillover_index_top_bottom %>%
  dplyr::mutate(rank = case_when(
    index > 50 ~ "top 10", 
    TRUE ~ 'bottom 10')) %>%
  ggplot(aes(x = reorder(name, index))) +
  # geom_hline(yintercept = 50) +
  geom_col(aes(y = index, fill = (rank)), show.legend = T) + 
  # ggnewscale::new_scale("fill") +
  geom_point(aes(y = -2, shape = group), show.legend = T) + # size = 1.2, 
  # scale_fill_manual(name = NULL, values=c('red', 'blue'), labels = c("top 10", "bottom 10"))+
  # scale_shape_manual(values=c(19, 1), labels = c("high income", "low income"))+
  scale_shape_manual(values=c(17, 15, 0, 6))+
  scale_fill_hue(direction = -1) +
  ylab('Impact Index') +
  coord_flip() +
  theme(axis.title.y=element_blank(), 
        legend.key.size   = unit(.3, 'cm'),  #change legend key size
        legend.key.height = unit(.3, 'cm'),  #change legend key height
        legend.key.width  = unit(.3, 'cm'),  #change legend key width
        legend.text = element_text(size=8),  #change legend text font size
        legend.position = c(0.7, 0.2), legend.margin=unit(0, "cm")) +
  guides(
   shape = guide_legend(order = 2, title = NULL, override.aes = list(fill  = c(NA, NA)), reverse = F),
   fill  = guide_legend(order = 1, title = NULL, override.aes = list(shape = c(NA, NA)), reverse = T)) 

fname <- paste0(dir.fig, 'spillover/', 'spillover_index_top_bottom_shape', timestamp, '.jpg'); fname
ggsave(filename = fname, plot = last_plot(), width = width_1col, height = 8, units = 'cm', dpi = 600)

## https://www.r-bloggers.com/2020/07/controlling-legend-appearance-in-ggplot2-with-override-aes/
```



  Label country group by `color`. 
  
```{r}
spillover_index_top_bottom %>%
  dplyr::mutate(rank = case_when(
    index > 50 ~ "top 10", 
    TRUE ~ 'bottom 10')) %>%
  ggplot(aes(x = reorder(name, index))) +
  geom_col(aes(y = index, fill = (rank)), show.legend = T) + 
  geom_point(aes(y = -2, color = group), show.legend = T) + # size = 1.2, 
  scale_fill_manual(values=c('#fee6ce', '#f16913'))+
  scale_color_manual(values=c('#2c7bb6', '#abd9e9', '#fdae61', '#d7191c'))+
  # scale_fill_hue(direction = -1) +
  ylab('Impact Index') +
  coord_flip() +
  theme(axis.title.y=element_blank(), 
        text = element_text(size = 10),
        legend.key.size   = unit(.3, 'cm'),  #change legend key size
        legend.key.height = unit(.3, 'cm'),  #change legend key height
        legend.key.width  = unit(.3, 'cm'),  #change legend key width
        legend.text = element_text(size=8),  #change legend text font size
        legend.position = c(0.8, 0.2), legend.margin=unit(0, "cm")) +
  guides(
   color = guide_legend(order = 2, title = NULL, override.aes = list(fill  = c(NA, NA)), reverse = F),
   fill  = guide_legend(order = 1, title = NULL, override.aes = list(shape = c(NA, NA)), reverse = T)) 

fname <- paste0(dir.fig, 'spillover/', 'spillover_index_top_bottom_color_', timestamp, '.jpg'); fname
ggsave(filename = fname, plot = last_plot(), width = width_2col/3*2, height = width_2col/2, units = 'cm', dpi = 600)
```


  It can be interesting to see the contribution of each spillover to the overall impact. 
  
  *To do*: order the list based on characters or property (social vs. environmental vs. economic vs. security ...)

```{r - Index rank with MC categories}
n_type <- length(unique(net_imports_fromAll$ind)); n_type
list20 <- unique(spillover_index_top_bottom$iso_a3); list20

spillover_index_type <- spillover_norm %>%
  dplyr::filter(year %in% c(2015)) %>%
  gather(key = 'indicator', value = 'score', 3:(ncol(.))) %>%
  dplyr::mutate(score_each = score/n_type) %>%
  dplyr::filter(iso3 %in% list20) %>%
  merge(x = ., 
        y = spillover_index_top_bottom %>% dplyr::select(-2, -3, -4, -5), 
        by.x = 'iso3', by.y = 'iso_a3', all.x = T) %>%
  
  ### link with what type of impacts - env, soc, eco, or sec?
  merge(x = ., y = direction, by.x = 'indicator', by.y = 'ind', all.x = T) %>%
  dplyr::mutate(SDG_class = as.factor(SDG_class)) %>%
  as.data.frame()
  
str(spillover_index_type)  
unique(spillover_index_type$indicator)
levels(spillover_index_type$SDG_class)

spillover_index_type_SDGtype <- spillover_index_type %>%
  dplyr::mutate(SDG_class = factor(SDG_class, levels = c("Envi", "Soci", "Econ",  "Secu")))
  

# Stacked
ggplot(spillover_index_type_SDGtype, 
       aes(#fill = indicator, 
           fill = fct_rev(SDG_class),
           y=score_each, x = reorder(iso3, index))) + 
  scale_fill_manual(values = c('#33a02c', '#fdbf6f', '#ff7f00', '#6a3d9a') %>% rev(), name = '') +
  geom_bar(position="stack", stat="identity", alpha = 0.8) +
  coord_flip() +
  theme(legend.position = c(0.8, 0.2), legend.margin=unit(0, "cm")) +
  ylab('Impact Index') + xlab('Country')

fname <- paste0(dir.fig, 'spillover/', 'spillover_index_top_bottom_ByType_', timestamp, '.jpg'); fname
ggsave(filename = fname, plot = last_plot(), width = width_2col/3*2, height = width_2col/2, units = 'cm', dpi = 600)
```



```{r - score of SE}
spillover_index_se_shp <- shp %>%
  merge(x = ., y = spillover_index_se, by.x = 'iso_a3', by.y = 'iso3', all.x = T) %>%
  arrange(!is.na(year))
# str(score_index_shp)

### to check if all the spillover data has been matched with the shp
spillover_index_se_shp_match_check <- spillover_index_se %>%
  dplyr::filter(year == 2015) %>%
  merge(y = shp, x = ., by.y = 'iso_a3', by.x = 'iso3', all.x = T) 
nrow(spillover_index_se_shp_match_check) ## ROW was not included here. 


map <- spillover_index_se_shp %>%
  dplyr::filter(!is.na(year)) %>%
  ggplot()+
  geom_sf(aes(fill = index), color='gray80', size = 0.1) +
  scale_fill_distiller(palette = "Spectral", direction = 1, na.value = 'black') +
  facet_grid(year~se)
map


spillover_index_se_shp %>%
  dplyr::filter(!is.na(year)) %>%
  dplyr::filter(se == 'e') %>%
  ggplot()+
  geom_sf(aes(fill = index), color='gray80', size = 0.1) +
  scale_fill_distiller(palette = "Spectral", direction = 1, na.value = 'black') +
  facet_grid(year~se)


timestamp <- format(Sys.time(), "%Y%m%d") ## %H%M%S
fname <- paste0(dir.fig, 'spillover/', 'map_spillover_index_se', '_', timestamp, '.jpg'); fname
ggsave(filename = fname, plot = map, width = width_2col, height = width_2col/2, units = unit_ns, dpi = 300)

```





```{r - score of each}
# install.packages("devtools")
# devtools::install_github("tidyverse/googlesheets4")

## 1. which to be chosen for mapping -------------
library(googlesheets4)
link <- 'https://docs.google.com/spreadsheets/d/13Di8K8ObDFfdALxrf-YjlGyYf_tNrm1TZ7yMDaozfzc/edit?usp=sharing'

### Footprint indicators
fts  <- googlesheets4::read_sheet(link, sheet = 1) %>%
  as.data.frame() %>%
  dplyr::filter(Used == '1', 
                !is.na(Filename),
                !grepl('\\?', Filename)) %>%
  dplyr::select(Filename, ShortName)




## 2. map the selected spillovers ------------------
yr <- 2015
spillover_norm_each_shp <-  shp %>%
  merge(x = ., y = spillover_norm, by.x = 'iso_a3', by.y = 'iso3', all.x = T) %>%
  gather(key = 'indicator', value = 'spillover_norm', (ncol(shp)+1):(ncol(.)-1)) %>%
  dplyr::filter(year == yr)


unique(spillover_norm_each_shp$indicator) %>% sort()


### merge and select indicators
map_each <- spillover_norm_each_shp %>%
  # dplyr::filter(year == yr) %>%
  merge(x = ., y = fts, by.x = 'indicator', by.y = 'Filename', all.x = T)

map_each_na <- map_each %>%
  st_drop_geometry() %>%
  dplyr::filter(is.na(ShortName))
unique(map_each_na$indicator) %>% sort()

map_each_ind <- map_each %>%
  st_drop_geometry() %>%
  dplyr::filter(!is.na(ShortName)) %>%
  distinct(ShortName, indicator)

ind_selected <- map_each_ind$indicator; ind_selected
ind_name     <- map_each_ind$ShortName; ind_name


map_each_p <- map_each %>%
  dplyr::filter(!is.na(ShortName)) %>%  ## remove un-matched 
  ggplot()+
  geom_sf(aes(fill = spillover_norm), color='gray80', size = 0.1) +
  scale_fill_distiller(palette = "Spectral", direction = -1, na.value = 'gray70', name= 'Impact Score') +
  facet_wrap(~ShortName, ncol = 5) +
  # ggtitle(yr)+
  theme(legend.position = c(0.85, 0.07)) +
  theme(panel.grid = element_blank(),
        axis.ticks = element_blank(),
        axis.text  = element_blank(),
        legend.key.size = unit(.2, 'cm'), #change legend key size
        plot.title   = element_text(size = 4),
        strip.text.x = element_text(size = 7)
        ) 
# map_each_p
fname <- paste0(dir.fig, 'spillover/', 'map_spillover_norm_each_', yr, '_long_', timestamp, '.jpg'); fname
ggsave(filename = fname, plot = map_each_p, width = 7, height = 7, units = 'in', dpi = 300)
```




**THE END** 


  This chuck aims to zoom in to EU region, which is small on the world map. 
  One can ignore this at this stage. 
  
```{r - zoom in map for EU, eval=FALSE, include=FALSE}
func_make_polygon <- function(lon_bounds, lat_bounds){
  pts <- c()
  for (j in lat_bounds) {
    for (i in lon_bounds) {
      pt <- c(i, j)
      pts <- rbind(pts, pt)
    }
  }
  print(pts)
  
  ptss <- rbind(pts[1,], pts[3,], pts[4,], pts[2,], pts[1,])
  pol <- st_polygon(list(ptss))
  return(pol)
}

zoom_to <- c(15, 53)  # lon, lat - EU
zoom_level <- 1.8
lon_span <- 180 / 2^zoom_level
lat_span <- 120 / 2^zoom_level
lon_bounds <- c(zoom_to[1] - lon_span / 2, zoom_to[1] + lon_span / 2)
lat_bounds <- c(zoom_to[2] - lat_span / 2, zoom_to[2] + lat_span / 2)

pol <- func_make_polygon(lon_bounds, lat_bounds)
str(pol)
plot(pol)


### crs ? ------------------------------------------------
### ## the units of the CRS are meters (rather than degrees)
crs_lnd <- st_crs(shp); crs_lnd
crs_lnd$epsg
# shp <- st_set_crs(shp, 4326) # set CRS

eu = data.frame(lon = 15, lat = 53) %>% st_as_sf(coords = c("lon", "lat"))
eu_buff_no_crs = st_buffer(eu, dist = 2)
plot(eu_buff_no_crs)

crs_my <- "+proj=longlat +datum=WGS84 +no_defs"   
pol2 <- st_sfc(pol,  crs = crs_my)
plot(pol2)



### plot -------------------------------------------------
map <- map +
  geom_sf(data = st_sfc(pol,  crs = 4326), color = 'black',  fill = NA, size = .2) 
map

map_eu <- map +
  geom_sf(data = st_sfc(st_point(zoom_to), crs = 4326), color = 'transparent', size = 1) +
  coord_sf(xlim = lon_bounds, ylim = lat_bounds) +
  theme_nothing() +
  theme(legend.position = "none",
        panel.border = element_rect(colour = NA, fill=NA, size=.2)) 
# map_eu

p <- ggdraw(map) +
  draw_plot(map_eu, x = -0.05, y = 0.25, width = .3, height = .2) +
  draw_plot_label(
    label = c("", ""),
    hjust = c(0, 0),
    vjust = c(0, 0),
    size = 9
  )
p

```




