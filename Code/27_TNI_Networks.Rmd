---
title: "Untitled"
author: "Yingjie"
date: "6/30/2021"
output: html_document
editor_options: 
  chunk_output_type: inline
---

# Overview

  To get the output for the analysis, we only need to run these two chunks
  - `#### --> All indicators`
  - `# 4. Plot network for each TNI`
  
  Other sections/chunks are for testing and selecting the best viz option. 
  
  

# 1. Introduction 


```{r include=FALSE}

### To clear your environment  -----------------------------------------------------------
remove(list = ls())


# Download the workshop materials: bit.ly/sunbelt-2021
# Online tutorial: kateto.net/sunbelt2021


# KEY PACKAGES
# Install those now if you do not have the latest versions. 
# (please do NOT load them yet!)

# install.packages("igraph") 
# install.packages("network") 
# install.packages("sna")
# install.packages("visNetwork")
# install.packages("threejs")
# install.packages("ndtv")


# OPTIONAL PACKAGES
# Install those if you  would like to run through all of the
# examples below (those are not critical and can be skipped).

# install.packages("png")
# install.packages("ggraph")
# install.packages("networkD3")
# install.packages("animation")
# install.packages("maps")
# install.packages("geosphere")

### packages -----------------------------------------------------------------------------
source('./Code/_package list.R')
# Download an archive with the data files from http://bit.ly/sunbelt-2021
# Load the 'igraph' library:
library(igraph)




### set work dir -------------------------------------------------------------------------
path <- rstudioapi::getSourceEditorContext()$path
dir  <- dirname(rstudioapi::getSourceEditorContext()$path); dir
setwd(dir)
setwd('..') # set directory by one folder up
getwd()

### data path
source('./Code/_path of data.R')

today <- format(Sys.time(), "%Y%m%d"); today
```


```{r}
## Remove columns from dataframe where ALL values are NA
not_all_na <- function(x) any(!is.na(x)) ## temp %>% select(where(not_all_na)) --> allow a few NA in the column 
not_any_na <- function(x) all(!is.na(x)) ## temp %>% select(where(not_any_na)) --> not allow any NA in the column
```





# 2. Load network data


## Ancillary data

```{r - iso3}
load('./Data/Ancillary_Data_ISO3code_shp.RData') ## iso_eora, pop, gdp, shp, grp, grp_update

grp <- rbind(
  grp, 
  data.frame(name='SUN', iso_a3 = 'SUN', 
             eco_group = '2.Developing', 
             inc_group = '4. Low income', 
             group = 'Low income'))

grp_update_net <- rbind(
  grp_update, 
  data.frame(name='ROW', iso_a3 = 'ROW', group_income4 = 'Low income', 
             group_income2 = 'Low income', group_economies = 'Developing'),
  data.frame(name='SUN', iso_a3 = 'SUN', group_income4 = 'Low income', 
             group_income2 = 'Low income', group_economies = 'Developing')
)

### extended country-iso3 pair list for matching
load('./Data/Ancillary_Data_iso_eora_ex.RData')  ## ## iso_eora_ex
```


```{r - direction}
### loop the normalization based on direction ------------------------------------------------------
# xls <- paste0('./Data/data_02_intermediate/dt02_flows/', "spillover_name_list_directions.xlsx"); xls
# direction <- readxl::read_excel(path = xls) %>%
#   dplyr::filter(!is.na(ind) & !is.na(direction))

f <- paste0('./Data/data_02_intermediate/dt02_flows/', 'direction.RData')
load(f) ## `direction`, `direction_clean`

direction_use <- direction %>%
  dplyr::filter(!is.na(direction)) %>%
  dplyr::filter(Used == 1) %>%
  dplyr::filter(!ind %in% c('Material_footprint')) %>% ## need to update this data!
  dplyr::select(ind, direction, everything())


# ind_selected <- unique(direction_use$ind)
```



## Network Data

### (1) Links and nodes

#### --> One indicator
```{r}
# -------~~ DATASET 1: edgelist  --------
 
# Read in the data:
# nodes <- read.csv("https://kateto.net/workshops/data/Dataset1-Media-Example-NODES.csv", header=T, as.is=T)
# links <- read.csv("https://kateto.net/workshops/data/Dataset1-Media-Example-EDGES.csv", header=T, as.is=T)

## names(nodes) --> "id"            "media"         "type"    "type.label"    "audience.size"
## names(links) --> "from"   "to"     "type"   "weight"

# ind <- 'Water'
ind <- 'student_flow'
ind <- 'Landuse_forest'
# ind <- 'osh_fatal'
xls <- paste0(dir.eora_cleaned, ind, '.xlsx'); xls


mat <- readxl::read_excel(xls) %>% 
  ungroup() %>%
  dplyr::filter(year == 2015) 

links <- mat %>%
  gather(key = 'to', value = 'weight', 4:ncol(.)) %>%
  dplyr::rename('from' = 'iso3') %>%
  dplyr::mutate(type = ind) %>%
  dplyr::select(-ctr, -year) %>%
  arrange(from, to) %>%
  distinct(from, to, .keep_all = T) %>%  ## ??? --> need to find out why
  
  dplyr::filter(!is.na(weight) & weight > 0) %>%
  # dplyr::filter(weight >= 5*10^3) %>%      ## ??? --> to reduce edges
  dplyr::mutate(pct = weight/sum(weight, na.rm = T)*100) %>%
  arrange(desc(pct)) %>%
  dplyr::mutate(pct_cumsum = cumsum(pct)) %>%
  # dplyr::filter(pct_cumsum < 80) %>%
  
  #########################################
  ## remove domestic flows -------------------
  dplyr::filter(from != to) %>%

  ## look at the top 15 flows
  # head(55) %>% ## 15
  ##########################################

  ## remove nodes with too few links (< 5 links)
  group_by(from) %>%
  dplyr::mutate(freq_from = n()) %>%
  dplyr::filter(freq_from >= 1) %>%   
  ungroup() %>%
  as.data.frame()

nodes <- 
  # readxl::read_excel(xls) %>%
  # ungroup() %>%
  # dplyr::filter(year == 2015) %>%
  # distinct(iso3, .keep_all = F) %>%
  
  data.frame(iso3 = c(links$from, links$to)) %>%
  dplyr::mutate(iso3 = as.character(iso3)) %>%
  dplyr::distinct(iso3, .keep_all = T) %>%
  
  merge(x = ., 
        y = grp_update_net, 
        by.x = 'iso3', by.y = 'iso_a3', all.x = T) %>%
  # dplyr::filter(name != 'N. Cyprus') %>%
  dplyr::distinct(iso3, .keep_all = T) %>%
  # dplyr::select(-group_income2) #%>%
  dplyr::mutate(group = as.factor(group_income2)) %>%
  merge(x = ., 
        y = pop %>% dplyr::select(iso3, `2015`), 
        by.x = 'iso3', by.y = 'iso3', all.x = T) %>%
  arrange(iso3) %>%
  dplyr::mutate(node_type  = ifelse(group == 'High income', 1, 0), 
                type.label = group) %>%
  dplyr::rename('id' = 'iso3', 'audience.size' = '2015', 'label' = 'name') %>%
  dplyr::mutate(label = id) %>%
  as.data.frame()

# Examine the data:
head(nodes)
head(links)
str(nodes)
str(links)

# setdiff(unique(links$from), nodes$id)
# setdiff(nodes$id, unique(links$from))


### to only include nodes listed in `links`
length(unique(nodes$id))

nodes_in_links <- c(links$from, links$to); nodes_in_links
nodes_in_links <- unique(nodes_in_links)
length(nodes_in_links)

nodes <- nodes %>%
  dplyr::filter(id %in% nodes_in_links)

str(nodes)

# Converting the data to an igraph object:
# The graph_from_data_frame() function takes two data frames: 'd' and 'vertices'.
# 'd' describes the edges of the network - it should start with two columns 
# containing the source and target node IDs for each network tie.
# 'vertices' should start with a column of node IDs.
# Any additional columns in either data frame are interpreted as attributes.

# ?graph.data.frame
```



#### --> All indicators
```{r}
xls.ls <- list.files(path = dir.eora_cleaned, pattern = 'xlsx$', full.names = T); xls.ls

### Get the list of files for SHDB data, and remove them from the whole list
library(stringr)
# xls.ls.SHDB <- str_subset(xls.ls, pattern="SHDB")
# xls.ls.other<- setdiff(xls.ls, xls.ls.SHDB); xls.ls.other; length(xls.ls.other)
# xls <- xls.ls.other[4]; xls 


### put all spillover indicators in one table 
links_scaled_all <- data.frame()

frac <- 0.025

for (i in 1:nrow(direction_use)) {

  ind <- direction_use[i, 1] %>% unlist() %>% paste(sep = '', collapse = ''); 
  drt <- direction_use[i, 2] %>% unlist() %>% paste(sep = '', collapse = '') %>% as.numeric()
  cat('\n\n', i, '\t', ind, '\t', drt, '\n')
  
  xls <- paste0(dir.eora_cleaned, ind, '.xlsx'); print(xls);
  mat <- readxl::read_excel(xls) %>% 
    ungroup() %>%
    ### use SHDB 2019 for 2015 --------------------!!!
    dplyr::mutate(year = ifelse(
      str_detect(string = ind, pattern = 'SHDB') & year == 2019, 2015, year)) %>%
    dplyr::filter(year == 2015) 

  links <- mat %>%
    gather(key = 'to', value = 'weight', 4:ncol(.)) %>%
    dplyr::rename('from' = 'iso3') %>%
    dplyr::mutate(type = ind) %>%
    dplyr::select(-ctr, -year) %>%
    arrange(from, to) %>%
    dplyr::distinct(from, to, .keep_all = T) %>%  
    ## remove domestic flows -------------------
    dplyr::filter(from != to) %>%
    as.data.frame()

  ### to re-scale each impact to 0-100 -------------------------------------------------------------
  links_scaled <- links %>%
    ungroup() %>%
    dplyr::mutate(
      x = weight,  
      ### cal upper/lower bounds ----------------------------
      max0  = max(x, na.rm = T),
      min0  = min(x, na.rm = T),
      max1  = x %>% unlist() %>% na.omit() %>% sort(decreasing = T) %>% dplyr::nth(n = round(length(.)*frac)),
      min1  = x %>% unlist() %>% na.omit() %>% sort(decreasing = T) %>% dplyr::nth(n = round(length(.)*(1-frac))),
      ### to decide which upper/lower bounds to use ---------
      max = max0,
      min = min0) %>% as.data.frame() %>%
    dplyr::mutate(
      # --> higher value means larger negative impact  ---------------------------------------------
      score = dplyr::case_when(drt < 0    ~ (x-min)/(max-min)*100,  ## the larger the larger
                               is.na(drt) ~ NA_real_,
                               TRUE       ~ (max-x)/(max-min)*100), ## the larger the smaller
      # --> to keep score value ranging from 0-100 -------------------------------------------------
      score = dplyr::case_when(is.na(score) ~ NA_real_,
                               score > 100  ~ 100,
                               score > 0    ~ score,
                               TRUE         ~ 0)
      ) %>%
    arrange(desc(x)) %>% 
    as.data.frame()
  
  links_scaled_all <- rbind(links_scaled_all, links_scaled)
}



links_scaled_all_Net <- links_scaled_all %>%
  dplyr::select(from, to, type, score) %>%
  spread(key = type, value = score) %>%
  dplyr::select(where(not_all_na)) %>% 
  ### total impact 
  dplyr::mutate(total = rowSums(across(where(is.numeric)), na.rm = T),
                n_na  = rowSums(is.na(.))) %>%  ## count NA in all the indicators
  dplyr::filter(n_na < ncol(.)/3) %>%           ## remove country-pair without sufficient available data
  as.data.frame()


hist(links_scaled_all_Net$n_na)
```





```{r - simplify}

### choose one of the indicators to compare 
ind <- 'Landuse_forest'
ind <- 'total'
  
links <- links_scaled_all_Net %>%
  dplyr::select(all_of(c('from', 'to', ind))) %>%
  dplyr::rename_at(3, ~"weight") %>%
  ## look at the top 15 flows
  arrange(desc(weight)) %>%
  head(105) %>% ## 55

  ## remove nodes with too few links (< 5 links)
  group_by(from) %>%
  dplyr::mutate(freq_from = n()) %>%
  dplyr::filter(freq_from >= 1) %>%   
  ungroup() %>%
  as.data.frame()


nodes <-
  data.frame(iso3 = c(links$from, links$to)) %>%
  dplyr::mutate(iso3 = as.character(iso3)) %>%
  dplyr::distinct(iso3, .keep_all = T) %>%

  merge(x = ., 
        y = grp_update_net, 
        by.x = 'iso3', by.y = 'iso_a3', all.x = T) %>%
  dplyr::distinct(iso3, .keep_all = T) %>%
  dplyr::mutate(group = as.factor(group_income2)) %>%
  merge(., pop %>% dplyr::select(iso3, `2015`), by.x = 'iso3', by.y = 'iso3', all.x = T) %>%
  arrange(iso3) %>%
  dplyr::mutate(node_type  = ifelse(group == 'High income', 1, 0), 
                type.label = group) %>%
  dplyr::rename('id' = 'iso3', 'audience.size' = '2015', 'label' = 'name') %>%
  dplyr::mutate(label = id) %>%
  as.data.frame()
```



### (2) Network
```{r}
net <- graph_from_data_frame(d=links, vertices=nodes, directed=T) 

# Examine the resulting object:
class(net)
net 

# We can access the nodes, edges, and their attributes:
E(net)
V(net)
E(net)$type
V(net)$label

# Or find specific nodes and edges by attribute:
# (that returns objects of type vertex sequence / edge sequence)
V(net)[label=="USA"]
# E(net)[type==ind]


### If you need them, you can extract an edge list 
# or a matrix back from the igraph networks.
# as_edgelist(net, names=T)
# as_adjacency_matrix(net, attr="weight")

### Or data frames describing nodes and edges:
# as_data_frame(net, what="edges")
# as_data_frame(net, what="vertices")


### You can also look at the network matrix directly:
# net[1,]
# net[5,7]



# First attempt to plot the graph:
# plot(net) # not pretty!


# Removing loops from the graph:
net <- igraph::simplify(net, remove.multiple = F, remove.loops = T) 

# Let's and reduce the arrow size and remove the labels:
plot(net, 
     edge.arrow.size =.3,
     edge.curved = 0.1,
     # vertex.label=NA,
     vertex.label.cex=.7)
```






# 3. Network plots in 'igraph'

## Plot parameters 

  We can set the node & edge options in two ways 
  - 1. to specify them in the plot() function
  - 2. to set attributes is to add them to the igraph object

```{r}
# Check out the node options (starting with 'vertex.') 
# and the edge options # (starting with 'edge.'). 
# A list of options is also included in your handout.

# ?igraph.plotting

### way 1 - to specify them in the plot() function -------------------------------------------------

### Plot with curved edges (edge.curved=.1) and reduce arrow size
# plot(net, edge.arrow.size=.4, edge.curved=.1)


### Set node color to orange and the border color to hex #555555
### Replace the vertex label with the node names stored in "label"
# dev.off()
plot(net, 
     edge.arrow.size=.2, 
     edge.curved = 0.2,
     vertex.color = "orange", 
     vertex.frame.color = "#555555",
     vertex.label = V(net)$label, 
     vertex.label.color="black",
     vertex.label.cex=0.7) 



### The second way to set attributes is to add them to the igraph object. --------------------------
```


### Nodes
```{r}
## (1) node colors ------------------------------------------
unique(nodes$inc_group)
length(unique(nodes$inc_group))
colrs <- c("lightblue", "tomato", "gold", 'green')
colrs <- c("#2c7bb6", "#abd9e9", "#fdae61", '#d7191c')
colrs <- adjustcolor(colrs, alpha.f = 0.7)


V(net)$inc_group
V(net)$color <- colrs[V(net)$inc_group %>% as.factor()]
V(net)$color


## (2) Node size --------------------------------------------
## (2.1) node size: Compute node `degrees` and use that to set node size:
deg <- igraph::degree(net, mode="in") ## 'out' for out-degree; 'in' for in-degree; 'total'/'all' for the sum of the two
hist(deg, breaks = 10)
V(net)$size <- (deg)*1


rescale = function(x,a,b,c,d){c + (x-a)/(b-a)*(d-c)}
V(net)$size <- rescale(deg, min(deg), max(deg), 5, 20)

## (2.2) node size: Alternatively, we can set node size based on audience size:
# V(net)$size <- log(V(net)$audience.size/10^3)

# V(net)$size <- 10

## (3) node labels ------------------------------------------
##  are currently node IDs. Setting them to NA will render no labels:
V(net)$label.color <- "black"
# V(net)$label <- NA
```



### Edges
```{r}
## (4) Edge width
##  based on weight you choose
##  Edge width, defaults to 1
E(net)$width <- round(E(net)$weight/10000, digits = 2); 
hist(E(net)$width)

### normalize the width values
# scalar <- function(x) {x / sqrt(sum(x^2))}
# E(net)$width <- round(scalar(E(net)$width)*10*5, digits = 2)
# hist(E(net)$width)
w <- E(net)$width
rescale = function(x,a,b,c,d){c + (x-a)/(b-a)*(d-c)}
E(net)$width <- rescale(w, min(w), max(w), 2, 10)
hist(E(net)$width)


## (5) edge color -------------------------------------------
##  5.1 one single color
E(net)$edge.color <- "gray80"

##  5.2 color the edges based on their source node color 
## We'll get the starting node for each edge with "ends()". 
##  It returns the start and end vertex for edges listed in the es parameter. 
##  The names parameter control whether the function returns edge names or IDs.
edge.start <- ends(net, es=E(net), names=F)[,1]; 
edge.col <- V(net)$color[edge.start]; edge.col
plot(net, edge.color = edge.col, edge.curved=.1)



## (6) Arrow size -------------------------------------------
E(net)$arrow.size <- .2


## (7) Network layout ---------------------------------------
graph_attr(net, "layout") <- layout_with_lgl
plot(net)


## (8) legend -----------------------------------------------
## We can also add a legend explaining the meaning of the colors we used 
# plot(net) 
# legend(x=-1.1, y=-1.1, c("Newspaper","Television", "Online News"), pch=21,
#        col="#777777", pt.bg=colrs, pt.cex=2.5, bty="n", ncol=1)



## (9) Other options ----------------------------------------
##     We can also override the attributes explicitly in the plot:
# plot(net, edge.color="orange", vertex.color="gray50") 



## Sometimes, especially with semantic networks, we may be interested in plotting only the labels of the nodes
# plot(net, 
#      vertex.shape="none", 
#      vertex.label=V(net)$label,
#      vertex.label.font=2, 
#      vertex.label.color="gray50",
#      vertex.label.cex=2, 
#      edge.color="black")
```





### Network Layouts

```{r}
# Network layouts are algorithms that return coordinates for each
# node in a network.

# Let's generate a slightly larger 100-node graph using 
# a preferential attachment model (Barabasi-Albert).

net <- net
# V(net)$size <- 8
V(net)$frame.color <- "white"
# V(net)$color <- "orange"
# V(net)$label <- "" 
# E(net)$arrow.mode <- 0
plot(net, vertex.label=V(net)$label)

# Now let's plot this network using the layouts available in igraph.
```




**Fruchterman-Reingold layout**

  Like other force-directed algorithms, it treats graphs as a physical system. Nodes are electrically charged particles that repulse each other when they get too close. Edges act as springs that pull connected nodes closer. 
  
  F-R is nice but *slow*, most often used in graphs smaller than ~1000 vertices.
  
```{r - Fruchterman-Reingold}
# dev.off()
l <- layout_with_fr(net)
plot(net, layout=l)


### With force-directed layouts, you can use the 'niter' parameter to control
### the number of iterations to perform. The default is 500, but you can lower
### it for large graphs to get results faster and check if they look reasonable.

l <- layout_with_fr(net, niter=50)
plot(net, layout=l, edge.color=edge.col, edge.curved=.2)



### The layout can also use edge weights. It checks for a 'weight' edge attribute
# in the network object, or you can use a 'weights' parameter in the function.
# Nodes connected by more heavily weighted edges are pulled closer together.
ws  <-  c(1, rep(100, ecount(net)-1)); length(ws)
lw <- layout_with_fr(net, weights=ws)
plot(net, layout=lw, edge.color=edge.col, edge.curved=.2) 
 

### You will also notice that the F-R layout is not deterministic - different runs will result in slightly 
### different configurations. Saving the layout. In l allows us to get the exact same result multiple times.
# par(mfrow=c(2,2), mar=c(1,1,1,1))

plot(net, layout=layout_with_fr, edge.color=edge.col, edge.curved=.2) 
plot(net, layout=layout_with_fr, edge.color=edge.col, edge.curved=.2) 
plot(net, layout=l,              edge.color=edge.col, edge.curved=.2) 
plot(net, layout=l,              edge.color=edge.col, edge.curved=.2) 

# dev.off()


### By default, the coordinates of the plots are rescaled to the [-1,1] interval
# for both x and y. You can change that with the parameter "rescale=FALSE"
# and rescale your plot manually by multiplying the coordinates by a scalar.
# You can use norm_coords to normalize the plot with the boundaries you want.
# This way you can create more compact or spread out layout versions.

# Get the layout coordinates:
l <- layout_with_fr(net)
# Normalize them so that they are in the -1, 1 interval:
l <- norm_coords(l, ymin=-1, ymax=1, xmin=-1, xmax=1)

# par(mfrow=c(2,2), mar=c(0,0,0,0))

plot(net, rescale=F, layout=l*0.4, edge.color=edge.col, edge.curved=.2) 
plot(net, rescale=F, layout=l*0.8, edge.color=edge.col, edge.curved=.2) 
plot(net, rescale=F, layout=l*1.2, edge.color=edge.col, edge.curved=.2) 
# plot(net, rescale=F, layout=l*1.6)

# dev.off()



### Some layouts have 3D versions that you can use with parameter 'dim=3' ----------------------------
# l <- layout_with_fr(net, dim=3)
# plot(net, layout=l)


### As you might expect, a 3D layout has 3 columns, for X, Y, and Z coordinates:
# l
```



**Kamada Kawai**
  Another popular force-directed algorithm that produces nice results for connected graphs is Kamada Kawai. Like Fruchterman Reingold, it attempts to minimize the energy in a spring system.

```{r - Kamada Kawai}
l <- layout_with_kk(net)
plot(net, layout=l, edge.color=edge.col, edge.curved=.1) 
```




  **Graphopt** is a force-directed layout that uses layering to help with visualizations of *large* networks.

  Graphopt parameters can change the mass and electric charge of nodes as well as the optimal spring length and the spring constant for edges. The parameter names are 
  - 'charge' (default 0.001),  
  - 'mass' (default 30),
  - 'spring.length' (default 0), and 
  - 'spring.constant' (default 1).
  
Tweaking those can lead to considerably different graph layouts.

```{r - Graphopt}
l  <- layout_with_graphopt(net)
l1 <- layout_with_graphopt(net, charge=0.0001)
l2 <- layout_with_graphopt(net, charge=0.0000001, mass = 30)
l3 <- layout_with_graphopt(net, charge=0.0000001, mass = 10)
l4 <- layout_with_graphopt(net, charge=0.0000001, mass = 10, spring.length = 1)

# par(mfrow=c(1,3), mar=c(1,1,1,1))
plot(net, layout=l,  edge.color=edge.col, edge.curved=.2) 
plot(net, layout=l1, edge.color=edge.col, edge.curved=.2) 
plot(net, layout=l2, edge.color=edge.col, edge.curved=.2) 
plot(net, layout=l3, edge.color=edge.col, edge.curved=.2) 
plot(net, layout=l4, edge.color=edge.col, edge.curved=.2) 
# dev.off()
```




  The **MDS (multidimensional scaling)** algorithm tries to place nodes based on some measure of similarity or distance between them. More similar nodes are plotted closer to each other. 
  
  By default, the measure used is based on the shortest paths between nodes in the network. That can be changed with the 'dist' parameter.
  
```{r - Multi-Dimensional Scaling}
plot(net, layout=layout_with_mds, edge.color=edge.col, edge.curved=.2)
```



  The **LGL** algorithm is for *large* connected graphs. Here you can specify a root the node that will be placed in the middle of the layout.
  
```{r - LGL ***}

library(extrafont)
loadfonts(device = "win")
# font_import(paths = 'Ari')
# windowsFonts(A=windowsFont("Arial Black"))


plot(net, layout=layout_with_lgl, 
     edge.color=edge.col, edge.curved= 0.1, 
     arrow.mode = 0, edge.arrow.size = 0.5, 
     vertex.label.family="Arial")


# l <- layout_with_lgl(net)
# l <- norm_coords(l, ymin=-1, ymax=1, xmin=-1, xmax=1)


fname <- paste0(dir.fig, 'Network_top15_', ind, '_lgl.png'); fname
png(filename = fname, width=5, height=5, units="in", res=300, bg = 'transparent') # , family = "A"

par(mfrow=c(1,1), mar=c(0,0,0,0))
plot(net, layout = layout_with_lgl, 
     edge.color = edge.col, edge.curved= 0.15, 
     arrow.mode = 1, edge.arrow.size = .5, edge.arrow.width = 1.1, 
     vertex.label.family="Arial", vertex.frame.color = "gray60", # Node border color
     vertex.label.cex= 1)
dev.off()


fname <- paste0(dir.fig, 'Network_top15_', ind, '_gem.png'); fname
png(filename = fname, width=5, height=5, units="in", res=300, bg = 'transparent') # , family = "A"

par(mfrow=c(1,1), mar=c(0,0,0,0))
plot(net, layout=layout_with_gem, edge.color=edge.col, edge.curved= 0.2, 
     arrow.mode = 0, edge.arrow.size = .5, edge.arrow.width=1.1, 
     vertex.label.family="Arial", vertex.frame.color = "gray60", # Node border color
     vertex.label.cex= 1)
dev.off()

## https://www.r-graph-gallery.com/248-igraph-plotting-parameters.html
```


```{r - dh **}
plot(net, layout=layout_with_dh, 
     edge.color=edge.col, edge.curved= 0.1, 
     arrow.mode = 0, edge.arrow.size = 0.5, 
     vertex.label.family="Arial")
```



```{r - All layouts}
# By default, igraph uses a layout called 'layout_nicely' which selects
# an appropriate layout algorithm based on the properties of the graph. 

# Check out all available layouts in igraph:
?igraph::layout_

layouts <- grep("^layout_", ls("package:igraph"), value=TRUE)[-1]; layouts

### Remove layouts that do not apply to our graph.
layouts <- layouts[!grepl("bipartite|merge|norm|sugiyama|tree", layouts)]


### plot all together
par(mfrow=c(3,5), mar=c(1,1,1,1))

for (layout in layouts) {
  print(layout)
  l <- do.call(layout, list(net)) 
  plot(net, edge.arrow.mode=0, layout=l, main=layout, edge.color=edge.col, edge.curved=.2) }

```



```{r - Clear plots}
dev.off()
```



# 4. Plot network for each TNI

```{r}
### functions
rescale = function(x,a,b,c,d){c + (x-a)/(b-a)*(d-c)}


for (i in 1:nrow(direction_use)) {
  
  ind     <- direction_use[i, 'ind']
  indname <- direction_use[i, 'ShortName']
  
  ### Data -----------------------------------------------------------------------------------------
  
  links <- links_scaled_all_Net %>%
    dplyr::select(c('from', 'to', ind)) %>%
    dplyr::rename_at(3, ~"weight") %>%
    ## look at the top 15 flows
    arrange(desc(weight)) %>%
    head(40) %>% ## 55
  
    ## remove nodes with too few links (< 2 links)
    group_by(from) %>%
    dplyr::mutate(freq_from = n()) %>%
    dplyr::filter(freq_from >= 2) %>%   
    ungroup() %>%
    as.data.frame()

  
  
  nodes <-
    data.frame(iso3 = c(links$from, links$to)) %>%
    dplyr::mutate(iso3 = as.character(iso3)) %>%
    dplyr::distinct(iso3, .keep_all = T) %>%
  
    merge(x = ., 
          y = grp_update_net, 
          by.x = 'iso3', by.y = 'iso_a3', all.x = T) %>%
    dplyr::distinct(iso3, .keep_all = T) %>%
    dplyr::mutate(group = as.factor(group_income2)) %>%
    merge(x = ., 
          y = pop %>% dplyr::select(iso3, `2015`), 
          by.x = 'iso3', by.y = 'iso3', all.x = T) %>%
    arrange(iso3) %>%
    dplyr::mutate(node_type  = ifelse(group == 'High income', 1, 0), 
                  type.label = group) %>%
    dplyr::rename('id' = 'iso3', 'audience.size' = '2015', 'label' = 'name') %>%
    dplyr::mutate(label = id) %>%
    as.data.frame()
  
  
  ### Network --------------------------------------------------------------------------------------
  net <- graph_from_data_frame(d=links, vertices=nodes, directed=T) 
  # Removing loops from the graph:
  net <- igraph::simplify(net, remove.multiple = F, remove.loops = T)
  
  
  
  
  ### Parameters for Nodes -------------------------------------------------------------------------
  
  ## (1) node colors 
  unique(nodes$group)
  length(unique(nodes$group))
  ### --> color scheme depends on the number of country categories
  if (length(unique(nodes$group)) == 2) {
    colrs <- c('#2371A6', '#F26463') 
    colrs <- adjustcolor(colrs, alpha.f = 0.7)
  } else {
    colrs <- c("#2c7bb6", "#abd9e9", "#fdae61", '#d7191c')
    colrs <- adjustcolor(colrs, alpha.f = 0.7)
  }
  
  V(net)$group
  V(net)$color <- colrs[V(net)$group %>% as.factor()]
  
  ## (2) Node size 
  deg <- igraph::degree(net, mode="in") ## 'out' for out-degree; 'in' for in-degree; 'total'/'all' for the sum of the two
  hist(deg, breaks = 10)
  V(net)$size <- (deg)*1
  
  
  V(net)$size <- rescale(deg, min(deg), max(deg), 5, 20)
  
  ## (3) node labels 
  V(net)$label.color <- "black"
  
  
  
  
  ### Parameters for Edges -------------------------------------------------------------------------
  
  ## (4) Edge width
  E(net)$width <- round(E(net)$weight/10000, digits = 2); 
  hist(E(net)$width)
  
  #### normalize the width values
  w <- E(net)$width
  
  E(net)$width <- rescale(w, min(w), max(w), 2, 10)
  
  ## (5) edge color 
  
  ## color the edges based on their source node color 
  edge.start <- ends(net, es=E(net), names=F)[,1]; 
  edge.col <- V(net)$color[edge.start]; edge.col
  
  ## (6) Arrow size 
  E(net)$arrow.size <- .3
  
  V(net)$frame.color <- "white"
  
  
  
  ### Plot -----------------------------------------------------------------------------------------
  library(extrafont)
  loadfonts(device = "win")

  fname <- paste0(dir.fig, 'Network/Network_top_', ind, '_lgl_', today, '.png'); print(fname)
  png(filename = fname, width=3.1, height=3.1, units="in", res=300, bg = 'transparent') # , family = "A"
  
  par(mfrow=c(1,1), mar=c(0,0,0,0))
  plot(net, 
       # main = ind,
       asp = 0, 
       layout = layout_with_lgl, 
       edge.color = edge.col, edge.curved= 0.15, 
       arrow.mode = 1, edge.arrow.size = .5, edge.arrow.width = 1.1, 
       vertex.label.family="Arial", 
       vertex.frame.color = "gray60", # Node border color
       vertex.label.cex= 0.5)           # Font size        
  title(main = indname, 
        outer = TRUE, 
        cex.main = 0.6, # font size
        adj  = 0,       # 0-1: left to right
        line = -0.5)    # negative line value to bring down the title)
  dev.off()
}
  
```


















## ---
## --- END ---------------------------------

## Highlighting aspects of the network
```{r}
# plot(net)

# Notice that our network plot is still not too helpful.
# We can identify the type and size of nodes, but cannot see
# much about the structure since the links we're examining are so dense.
# One way to approach this is to see if we can sparsify the network.

hist(links$weight)
mean(links$weight)
sd(links$weight)

# There are more sophisticated ways to extract the key edges,
# but for the purposes of this exercise we'll only keep ones
# that have weight higher than the mean for the network.

# We can delete edges using delete_edges(net, edges)
# or, by the way, add edges with add_edges(net, edges) 
cut.off <- mean(links$weight) 
net.sp <- delete_edges(net, E(net)[weight<cut.off])
plot(net.sp, layout=layout_with_kk) 
plot(net.sp, layout=layout_with_lgl)


# Another way to think about this is to plot the two tie types 
# (hyperlinks and mentions) separately. We will do that in 
# section 5 of this tutorial: Plotting multiplex networks.
```


```{r Community detection}
# We can also try to make the network map more useful by showing the communities within it.

# Community detection (by optimizing modularity over partitions):
clp <- cluster_optimal(net)
class(clp)
clp$membership

# Community detection returns an object of class "communities" 
# which igraph knows how to plot: 
plot(clp, net)
 

# We can also plot the communities without relying on their built-in plot:
V(net)$community <- clp$membership
unique(V(net)$community)
colrs <- adjustcolor( c("gray50", "tomato", "gold", "yellowgreen", 'lightblue'), alpha=.6)
plot(net, vertex.color = colrs[V(net)$community])
```



*## Highlighting specific nodes or links
```{r}

```



*## Interactive plotting with 'tkplot'
```{r}

```




*# 4. Plotting two-mode networks
```{r}

```



*# 5. Plotting multiplex networks
```{r}

```




# 6. Beyond igraph: Statnet, ggraph, and simple charts

## network
```{r eval=FALSE, include=FALSE}

# The 'igraph' package is only one of many available network visualization options in R.
# This section provides a few quick examples illustrating other available approaches to
# static network visualization.


# -------~~  A 'network' package example (for Statnet users) -------- 
 

# Plotting with the 'network' package is very similar to that with 'igraph' -
# although the notation is slightly different (a whole new set of parameter names!)
# Here is a quick example using the (by now very familiar) media network.

#Just in case we have forgotten this earlier:
dev.off()
detach("package:igraph")

# Load our main package:
library("network")

# Wait, what did our data look like?
head(links)
head(nodes)

# Convert the data into the network format used by the Statnet family.
# As in igraph, we can generate a 'network' object from an edgelist, 
# an adjacency matrix, or an incidence matrix. 
?edgeset.constructors

# Remember to set the ignore.eval to F for weighted networks.

net3 <- network::network(x = links, 
                         vertex.attr = nodes %>% 
                           dplyr::rename(type = type.label)%>% 
                           dplyr::mutate(across(where(is.factor), as.character)), 
                         matrix.type = "edgelist", directed = T,
                loops=T, multiple=F, ignore.eval = F)
net3

# You can access the edges, vertices, and the network matrix using:
net3[,]
# net3 %n% "net.name" <- "Media Network" #  network attribute
net3 %v% "group"  # Node attribute
net3 %e% "type"     # Edge attribute
 
net3 %v% "col" <- c("gray70", "tomato", "gold", 'red')[net3 %v% "group"]

# plot the network:
plot(net3, vertex.cex=(net3 %v% "audience.size")/7, vertex.col= net3 %v% "col")

### For a full list of parameters that you can use in this plot, heck out ?plot.network.
# ?plot.network

# Note that - as in igraph - the plot returns the node position coordinates.
l <- plot(net3, vertex.cex=(net3 %v% "audience.size")/7, vertex.col="col")
plot(net3, vertex.cex=(net3 %v% "audience.size")/7, vertex.col="col", coord=l)


# The network package also offers the option to edit a plot interactively,
# by setting the parameter interactive=T

plot(net3, vertex.cex=(net3 %v% "audience.size")/7, vertex.col="col", interactive=T)


detach("package:network")
```



## ggraph

  A 'ggraph' package example (for ggplot2 fans)

```{r }
# The 'ggplot2' package and its extensions are known for offering the most
# meaningfully structured and advanced way to visualize data in R.
# In ggplot2, you can select from a variety of visual building blocks
# and add them to your graphics one by one, a layer at a time.

# The 'ggraph' package takes this principle and extends it to network data. 
# Here we'll just cover the basics: for a deeper look, it would be best
# to get familiar with ggplot2 first, then learn the specifics of ggraph.

library(ggraph)
library(igraph)

# We can use our 'net' igraph object directly with the 'ggraph' package.
# The following code gets the data and adds layers for nodes and links.

ggraph(net) +
  geom_edge_link() +   # add edges to the plot
  geom_node_point()    # add nodes to the plot


# You will recognize some graph layouts familiar from igraph plotting:
# 'star', 'circle', 'grid', 'sphere', 'kk', 'fr', 'mds', 'lgl', etc.

ggraph(net, layout="lgl") +
  geom_edge_link() +
  ggtitle("Look ma, no nodes!")  # add title to the plot


# Use geom_edge_link() for straight edges, geom_edge_arc() for curved ones, and
# geom_edge_fan() to make sure any overlapping multiplex edges will be fanned out.
# As in other packages, here we can set visual properties for the network plot by
# using various parameters, for nodes ('color', 'fill', 'shape', 'size', 'stroke') 
# and edges ('color', 'width', 'linetype'). Here too 'alpha' controls transparency.

ggraph(net, layout="lgl") +
  geom_edge_fan(color="gray50", width=0.8, alpha=0.5) + 
  geom_node_point(color=V(net)$color, size=8) +
  theme_nothing()



### As in ggplot2, we can add different themes to the plot. For a cleaner look,
### you can use an empty theme with theme_minimal() and theme_void() 
# ggraph(net, layout = 'linear') + 
#     geom_edge_arc(color = "orange", width=0.7) +
#     geom_node_point(size=5, color="gray50") +
#     theme_void()



# 'ggraph' also uses the 'ggplot2' way of mapping aesthetics: that is  
# to say specifying which elements of the data should correspond to different 
# visual properties of the graphic. This is done using the aes() function
# that matches visual parameters with attribute names from the data.

ggraph(net, layout="lgl") +
  geom_edge_link(aes(color = type)) +           # colors by edge type 
  geom_node_point(aes(size = size), color=V(net)$color) +  # size by audience size  
  theme_void()

# The edge attribute 'type' and node attribute 'audience.size' are 
# taken from our data as they are included in the igraph object 'net'

# One great thing about ggplot2 and ggraph is that they automatically
# generate a legend which makes plots easier to interpret.

# We can add node labels with geom_node_text() or geom_node_label():
ggraph(net,  layout = 'lgl') +
       
  geom_node_point(aes(size = size*100, fill = group, color = group), 
                  shape = 16, 
                  color=V(net)$color,
                  show.legend = F, alpha = 1) +    
  geom_edge_arc(
                strength=0.1, show.legend = F,
                # color ="gray", 
                aes(width = width, color = from), 
                alpha = 0.5, 
                start_cap = circle(2, 'mm'),
                end_cap = circle(2, 'mm'),
                arrow = arrow(length = unit(2, 'mm'))) +       
  geom_node_text(aes(label = label), color="gray10", repel=T) +
  theme_void()

# Note that 'ggraph' offers a number of other interesting ways to represent
# networks(e.g. dendrograms, treemaps, hive plots, circle plots)



```



```{r - ggraph advanced}
library(ggraph)
library(igraph)
got_palette <- c("#1A5878", "#C44237", "#AD8941", "#E99093")


ggraph(net, layout = "centrality", cent = graph.strength(net))+
  # geom_edge_link0(aes(edge_width = weight), edge_colour = "grey66")+
  geom_edge_arc(
                strength=0.1, show.legend = F, 
                # color ="gray", 
                aes(width = weight, color = from), 
                alpha = 0.5, 
                start_cap = circle(2, 'mm'),
                end_cap = circle(5, 'mm'),
                arrow = arrow(length = unit(3, 'mm'))) + 
  geom_node_point(aes(fill = group, size = size), shape = 21) +
  geom_node_text(aes(label = label), family = "Arial")+ # size = size, 
  scale_edge_width_continuous(range = c(1, 10))+
  scale_size_continuous(range = c(5, 15))+
  scale_fill_manual(values = got_palette)+
  coord_fixed()+
  theme_graph()+
  theme(legend.position = "none")


# detach("package:ggraph")
```


## heatmap
```{r }
# -------~~ Other ways to represent a network -------- 

# This section is a reminder that there are other ways to represent a network.
# For example, we can create a heatmap of a network matrix.

# First, we'll extract a matrix from our igraph network object. 
netm <-  as_adjacency_matrix(net, attr="weight", sparse=F)
colnames(netm) <- V(net)$label
rownames(netm) <- V(net)$label

# Generate a color palette to use in the heatmap:
palf <- colorRampPalette(c("gold", "dark orange")) 

# The Rowv & Colv parameters turn dendrograms on and off
heatmap(netm[,17:1], Rowv = NA, Colv = NA, col = palf(20), 
        scale="none", margins=c(10,10) )


# Degree distribution
deg.dist <- degree_distribution(net, cumulative=T, mode="all")
plot( x=0:max(degree(net)), y=1-deg.dist, pch=19, cex=1.4, col="orange", 
      xlab="Degree", ylab="Cumulative Frequency")
```



*# 7. Simple plot animations in R

```{r}

```




# 8. Interactive JavaScript networks
```{r}
# ================ 8. Interactive JavaScript networks ================


# There are a number of libraries like 'rcharts' and 'htmlwidgets' that can help you 
# export interactive web charts from R. We'll take a quick look at three packages that
# can export networks from R to JavaScript: : 'visNetwork' and 'threejs', and 'networkD3'


# -------~~  Interactive networks with visNetwork --------

# install.packages("visNetwork")

library("visNetwork") 

head(nodes)
head(links)

# We can visualize the network right away - visNetwork() will accept 
# our node and link data frames (it needs node data with an 'id' column,
# and edge data with 'from' and 'to' columns).

visNetwork(nodes, links)

# We can set the height and width of the  visNetwork() window 
# with parameters 'height' and 'width', the back color with 'background',
# the title, subtitle, and footer with 'main', 'submain', and 'footer'

visNetwork(nodes, links, height="600px", width="100%", background="#eeefff",
           main="Network", submain="And what a great network it is!",
           footer= "Hyperlinks and mentions among label sources")

# Like 'igraph' did, 'visNetwork' allows us to set graphic properties 
# as node or edge attributes directly in the data or through a function.

# Check out the available options with:
# ?visNodes
# ?visEdges
 

# We'll start by adding new node and edge attributes to our dataframes. 
vis.nodes <- nodes
vis.links <- links

# The options for node shape include 'ellipse', 'circle', 
# 'database', 'box', 'text', 'image', 'circularImage', 'diamond', 
# 'dot', 'star', 'triangle', 'triangleDown', 'square', and 'icon'

vis.nodes$shape  <- "dot"  
vis.nodes$shadow <- TRUE # Nodes will drop shadow
vis.nodes$title  <- vis.nodes$label # Text on click
vis.nodes$label  <- vis.nodes$type.label # Node label
vis.nodes$size   <- vis.nodes$size # Node size
vis.nodes$borderWidth <- 2 # Node border width
 
# We can set the color for several elements of the nodes:
# "background" changes the node color, "border" changes the frame color;
# "highlight" sets the color on click, "hover" sets the color on mouseover.

vis.nodes$color.background <- c("slategrey", "tomato", "gold")[nodes$type]
vis.nodes$color.border <- "black"
vis.nodes$color.highlight.background <- "orange"
vis.nodes$color.highlight.border <- "darkred"

visNetwork(vis.nodes, vis.links)

# Below we change some of the visual properties of the edges:

vis.links$width <- 1+links$weight/8 # line width
vis.links$color <- "gray"    # line color  
vis.links$arrows <- "middle" # arrows: 'from', 'to', or 'middle'
vis.links$smooth <- FALSE    # should the edges be curved?
vis.links$shadow <- FALSE    # edge shadow

visNetwork(vis.nodes, vis.links)

# Remove the arrows and set the edge width to 1:
vis.links$arrows <- "" 
vis.links$width  <- 1
visnet <- visNetwork(vis.nodes, vis.links)
visnet

# We can also set the visualization options directly with visNodes() and visEdges()
visnet2 <- visNetwork(nodes, links)
visnet2 <- visNodes(visnet2, shape = "square", shadow = TRUE, 
                    color=list(background="gray", highlight="orange", border="black"))
visnet2 <- visEdges(visnet2, color=list(color="black", highlight = "orange"),
                    smooth = FALSE, width=2, dashes= TRUE, arrows = 'middle' ) 
visnet2


# 'visNetwork' offers a number of options, including highlighting the neighbors
#  of a selected node, or adding a drop-down menu to select a subset of nodes. 
# The subset is based on a column from our data - here the type label. 
visOptions(visnet, highlightNearest = TRUE, selectedBy = "type.label")
 

# 'visNetwork' can also work with predefined groups of nodes.
# Visual characteristics for each group can be set with visGroups().
nodes$group <- nodes$type.label 
visnet3 <- visNetwork(nodes, links)
visnet3 <- visGroups(visnet3, groupname = "Newspaper", shape = "square",
                     color = list(background = "gray", border="black"))
visnet3 <- visGroups(visnet3, groupname = "TV", shape = "dot",       
                     color = list(background = "tomato", border="black"))
visnet3 <- visGroups(visnet3, groupname = "Online", shape = "diamond",   
                     color = list(background = "orange", border="black"))
visLegend(visnet3, main="Legend", position="right", ncol=1) 


# For more information, check out:
?visOptions # available options 
?visLayout  # available layouts
?visGroups  # using node groups
?visLegend  # adding a legend
 
detach("package:visNetwork")
```



## threejs

  Interactive networks with threejs. Another package exporting networks from R to a js library is 'threejs'; The nice thing about it is that it can read igraph objects.

```{r}
# install.packages("threejs")

# If you get errors or warnings using this library and the latest R version,
# try installing the development version of the 'htmlwidgets' package
# devtools::install_github('ramnathv/htmlwidgets')


library(threejs)
library(htmlwidgets)
library(igraph)
 
# The main network plotting function - graphjs() will take an igraph object.
# We could use our initial 'net' object with a slight modification - we will
# delete its graph layout and let 'threejs' generate its own layout.
# (We cheated a bit by assigning a function to the layout attribute above 
# rather than giving it a table of node coordinates. This is fine by 'igraph',
# but 'threejs' will not let us do it.
 
net.js <- net
graph_attr(net.js, "layout") <- NULL

# Note that RStudio for Windows may not render the 'threejs' graphics properly.
# We will save the output in an HTML file and open it in a browser.
# Some of the parameters that we can add include 'main' for the plot title;
# 'curvature' for the edge curvature; 'bg' for background color; 
# 'showLabels' to set labels to visible (TRUE) or not (FALSE); 
# 'attraction' and 'repulsion' to set how much nodes attract and repulse
# each other; 'opacity' for node transparency (0 to 1); 'stroke' to indicate
# whether nodes should be framed in a black circle (TRUE) or not (FALSE), etc.
# For the full list of parameters, check out ?graphjs

gjs <- graphjs(net.js, main="Network", bg="gray10", showLabels=F, stroke=F, 
               curvature=0.2, attraction=0.9, repulsion=0.8, opacity=0.9)
print(gjs)
saveWidget(gjs, file="Media-Network-gjs.html")
browseURL("Media-Network-gjs.html")
 
# Once we open the resulting visualization in the browser, we can use the mouse to
# control it: scrollwheel to zoom in and out, the left mouse button to rotate 
# the network, and the right mouse button to pan. 

# We can also create simple animations with 'threejs' by using lists of
# layouts, vertex colors, and edge colors that will switch at each step.

gjs.an <- graphjs(net.js, bg="gray10", showLabels=F, stroke=F, 
                  layout=list(layout_randomly(net.js, dim=3),
                              layout_with_fr(net.js,  dim=3),
                              layout_with_drl(net.js, dim=3),  
                              layout_on_sphere(net.js)),
                  vertex.color=list(V(net.js)$color, "gray", "orange", V(net.js)$color),
                  main=list("Random Layout", "Fruchterman-Reingold", "DrL layout", "Sphere" ) )
print(gjs.an)
saveWidget(gjs.an, file="Media-Network-gjs-an.html")
browseURL("Media-Network-gjs-an.html")

# Another example is the 'Les Miserables' network included with the package:

data(LeMis)
lemis.net <- graphjs(LeMis, main="Les Miserables", showLabels=T)
print(lemis.net)
saveWidget(lemis.net, file="LeMis-Network-gjs.html")
browseURL("LeMis-Network-gjs.html")
 
detach(package: igraph)
detach(package: threejs)
detach(package: htmlwidgets)
```




## networkD3 ?

  Another package using JavaScript to export networks: networkD3

```{r}

# install.packages("networkD3")

library(networkD3) 
 
# d3ForceNetwork expects node IDs that are numeric and start from 0
# so we have to transform our character node IDs:

links.d3 <- data.frame(from=as.numeric(factor(links$from))-1, 
                       to=as.numeric(factor(links$to))-1)

# The nodes need to be in the same order as the "source" column in links:
nodes.d3 <- cbind(idn=factor(nodes$label, levels=nodes$label), nodes) 

nodes_d3 <- mutate(nodes, id = as.numeric(rownames(nodes))-1)
links.d3 <- mutate(links, from=as.numeric(factor(links$from))-1, 
                   to=as.numeric(factor(links$to))-1,
                   w = (weight)/100)

# The `Group` parameter is used to color the nodes.
# Nodesize is not (as you might think) the size of the node, but the
# number of the column in the node data that should be used for sizing.
# The `charge` parameter guides node repulsion (if negative) or 
# attraction (if positive).

forceNetwork(Links = links.d3, Nodes = nodes.d3, Source="from", Target="to",
             NodeID = "idn", Group = "type.label", Value = 'w',
             linkColour = "#afafaf", arrows = T, 
             fontSize=12, legend = T,
             # Nodesize=6, 
             opacity = 1, #charge=-600, 
             # width = 600, height = 600, 
             zoom = T)
                 

detach(package: networkD3)
```




# 9. Interactive and dynamic networks with ndtv-d3

## ndtv

```{r}

# install.packages("ndtv", dependencies=T)

library("ndtv")

# You should not need additional software to produce web animations with 'ndtv' (below).
# If you want to save the animations as  video  files ( see ?saveVideo), you have to
# install a video converter called FFmpeg (ffmpg.org). To find out how to get the right 
# installation for your OS, check out ?install.ffmpeg  To use all available layouts, 
# you need to have Java installed on your machine.


# Remember net3, our original media network turned into a 'network' object:
net3 

# Let's create an interactive (but not yet dynamic!) visualization of net3.
# You will recognize a lot of the plotting parameters from 'network':
# Two new parameters set the tooltips (the popup labels you see when you 
# click on network elements); note that those can take html format.
# 'launchBrowser=T' will open file 'filename' in your default browser.

render.d3movie(net3, usearrows = F, displaylabels = F, bg="#111111", 
               vertex.border="#ffffff", vertex.col =  net3 %v% "col",
               vertex.cex = (net3 %v% "audience.size")/8, 
               edge.lwd = (net3 %e% "weight")/3, edge.col = '#55555599',
               vertex.tooltip = paste("<b>Name:</b>", (net3 %v% 'media') , "<br>",
                                    "<b>Type:</b>", (net3 %v% 'type.label')),
               edge.tooltip = paste("<b>Edge type:</b>", (net3 %e% 'type'), "<br>", 
                                  "<b>Edge weight:</b>", (net3 %e% "weight" ) ),
               launchBrowser=T, filename="Media-Network.html" )  

    
# If you are going to embed this in a markdown document, 
# you would also need to add output.mode='inline' above.


# -------~~ Network evolution animations -------- 


# In order to work with the network animations in 'ndtv', 
# we need to understand the  dynamic network format used by 
# Statnet packages, implemented in 'networkDynamic'. It can 
# represent discrete or continuous longitudinal network structures. 

# Let's look at one of the example datasets included in the
# package, containing simulation data based on the network of
# business connections among Renaissance Florentine families:

data(short.stergm.sim)
short.stergm.sim 
head(as.data.frame(short.stergm.sim))

# We can also use 'network.extract()' to get a network that 
# only contains elements active at a given point/time interval.

# Plot the network ignoring time (all nodes & edges that were ever present):
plot(short.stergm.sim)  

# Plot the network at time 1 (at=1):
plot( network.extract(short.stergm.sim, at=1) )

# Plot nodes & edges active for the entire period (`rule=all`) from 1 to 5:
plot( network.extract(short.stergm.sim, onset=1, terminus=5, rule="all") )

#Plot nodes & edges active at any point (`rule=any`) between 1 and 10:
plot( network.extract(short.stergm.sim, onset=1, terminus=10, rule="any") ) 

# Let's make a quick d3 animation from the example network:
render.d3movie(short.stergm.sim,displaylabels=TRUE) 


# Next, we will create and animate our own dynamic network.

# Dynamic network object can be generated in a number of ways: from 
# a set of networks/matrices representing different time points, or from
# data frames/matrices with node lists and edge lists indicating when each
# is active, or when they switch state. See ?networkDynamic for more information.

net3
plot(net3)

vs <- data.frame(onset=0, terminus=50, vertex.id=1:17)
es <- data.frame(onset=1:49, terminus=50, 
                 head=as.matrix(net3, matrix.type="edgelist")[,1],
                 tail=as.matrix(net3, matrix.type="edgelist")[,2])
head(vs)
head(es)

net3.dyn <- networkDynamic(base.net=net3, edge.spells=es, vertex.spells=vs)


# Plot the network (all elements present at any time point): 
plot(net3.dyn, vertex.cex=(net3 %v% "audience.size")/7, vertex.col="col")


# Plot static images showing network evolution:


compute.animation(net3.dyn, animation.mode = "kamadakawai",
                  slice.par=list(start=0, end=49, interval=10, 
                         aggregate.dur=10, rule='any'))

# Show time evolution through static images at different time points:
 filmstrip(net3.dyn, displaylabels=F, mfrow=c(2, 3),
           slice.par=list(start=0, end=49, interval=10, 
                         aggregate.dur=10, rule='any'))
 
# We can pre-compute the animation coordinates (otherwise they get calculated when 
# you generate the animation). Here 'animation.mode' is the layout algorithm - 
# one of "kamadakawai", "MDSJ", "Graphviz"and "useAttribute" (user-generated).

# Here 'slice.par' is a list of parameters controlling how the network visualization 
# moves through time. The parameter 'interval' is the time step between layouts, 
# 'aggregate.dur' is the period shown in each layout, 'rule' is the rule for 
# displaying elements (e.g. 'any': active at any point during that period, 
# 'all': active during the entire period, etc.)
 

# Let's make an actual animation: 
 
compute.animation(net3.dyn, animation.mode = "kamadakawai",
                  slice.par=list(start=0, end=50, interval=1, 
                         aggregate.dur=1, rule='any'))


render.d3movie(net3.dyn, usearrows = F, 
               displaylabels = F, label=net3 %v% "media",
               bg="#ffffff", vertex.border="#333333",
               vertex.cex = degree(net3)/2,  
               vertex.col = net3.dyn %v% "col",
               edge.lwd = (net3.dyn %e% "weight")/3, 
               edge.col = '#55555599',
               vertex.tooltip = paste("<b>Name:</b>", (net3.dyn %v% "media") , "<br>",
                                    "<b>Type:</b>", (net3.dyn %v% "type.label")),
               edge.tooltip = paste("<b>Edge type:</b>", (net3.dyn %e% "type"), "<br>", 
                                  "<b>Edge weight:</b>", (net3.dyn %e% "weight" ) ),
               launchBrowser=T, filename="Media-Network-Dynamic.html",
               render.par=list(tween.frames = 30, show.time = F),
               plot.par=list(mar=c(0,0,0,0)) )


# In addition to dynamic nodes and edges, 'ndtv' takes dynamic attributes.
# We could have added those to the 'es' and 'vs' data frames above.
# However, the plotting function can also evaluate parameters
# and generate dynamic arguments on the fly. For example,
# function(slice) { do some calculations with slice } will perform operations
# on the current time slice network, letting us change parameters dynamically.

# See the node size below:

compute.animation(net3.dyn, animation.mode = "kamadakawai",
                  slice.par=list(start=0, end=50, interval=4, 
                         aggregate.dur=1, rule='any'))


render.d3movie(net3.dyn, usearrows = F, 
               displaylabels = F, label=net3 %v% "media",
               bg="#000000", vertex.border="#dddddd",
               vertex.cex = function(slice){ degree(slice)/2.5 },  
               vertex.col = net3.dyn %v% "col",
               edge.lwd = (net3.dyn %e% "weight")/3, 
               edge.col = '#55555599',
               vertex.tooltip = paste("<b>Name:</b>", (net3.dyn %v% "media") , "<br>",
                                    "<b>Type:</b>", (net3.dyn %v% "type.label")),
               edge.tooltip = paste("<b>Edge type:</b>", (net3.dyn %e% "type"), "<br>", 
                                  "<b>Edge weight:</b>", (net3.dyn %e% "weight" ) ),
               launchBrowser=T, filename="Media-Network-even-more-Dynamic.html",
               render.par=list(tween.frames = 25, show.time = F) )

detach("package:ndtv")
detach("package:sna")
detach("package:networkDynamic")
detach("package:network")
```




# 10. Plotting networks on a geographic map

  The example below plots a network on a map using base R and mapping libraries.
Note that for those familiar with it, the package 'ggplot2' may provide
a more flexible way of doing this. Things there work similarly to below,
but you would use borders() to plot the map and geom_path() for the edges.

```{r}

# rm(list = ls()) # clear the workspace 


# In order to plot on a map, we'll need two additional packages.
# If you do not already have them, install those now:
# install.packages("maps")
# install.packages("geosphere")

library("maps")
library("geosphere")

# Package 'maps' has built-in maps it can plot for you. For example:
# ('col' is map fill, 'border' is  border color, 'bg' is  background color)
par(mfrow = c(2,2))
map("usa", col="tomato",  border="gray10", fill=TRUE, bg="gray30")
map("state", col="orange",  border="gray10", fill=TRUE, bg="gray30")
map("county", col="palegreen",  border="gray10", fill=TRUE, bg="gray30")
map("world", col="skyblue",  border="gray10", fill=TRUE, bg="gray30")

dev.off()

# The data we will use contains US airports and flights among them. 
# The airport file includes info about latitude and longitude.
# If we did not have those, we could use 'geocode()' from 'ggmap'
# to get latitude and longitude for an address.

airports <- read.csv("https://kateto.net/workshops/data/Dataset3-Airlines-NODES.csv", header=TRUE) 
flights <- read.csv("https://kateto.net/workshops/data/Dataset3-Airlines-EDGES.csv", header=TRUE, as.is=TRUE)

head(flights)
head(airports)

# Select only large airports: ones with more than 10 connections in the data.
tab <- table(flights$Source)
big.id <- names(tab)[tab>10]
airports <- airports[airports$ID %in% big.id,]
flights  <- flights[flights$Source %in% big.id & 
                    flights$Target %in% big.id, ]


# Plot a map of the united states:
map("state", col="grey20", fill=TRUE, bg="black", lwd=0.1)

# Add a point on the map for each airport:
points(x=airports$longitude, y=airports$latitude, pch=19, 
       cex=airports$Visits/80, col="orange")

# Generate edge colors: lighter color means higher flight volume.
col.1 <- adjustcolor("orange red", alpha=0.4)
col.2 <- adjustcolor("orange", alpha=0.4)
edge.pal <- colorRampPalette(c(col.1, col.2), alpha = TRUE)
edge.col <- edge.pal(100)

# For each flight, we will generate the coordinates of an arc that connects
# its star and end point, using gcIntermediate() from package 'geosphere'.
# Then we will plot that arc over the map using lines().
for(i in 1:nrow(flights))  {
    node1 <- airports[airports$ID == flights[i,]$Source,]
    node2 <- airports[airports$ID == flights[i,]$Target,]
    
    arc <- gcIntermediate( c(node1[1,]$longitude, node1[1,]$latitude), 
                           c(node2[1,]$longitude, node2[1,]$latitude), 
                           n=1000, addStartEnd=TRUE )
    edge.ind <- round(100*flights[i,]$Freq / max(flights$Freq))
    
    lines(arc, col=edge.col[edge.ind], lwd=edge.ind/30)
}


```

