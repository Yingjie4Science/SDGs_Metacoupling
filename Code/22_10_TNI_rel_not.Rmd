---
title: "Spillover Analysis"
author: "Yingjie Li"
date: "2021-03-01 (Updated: 2021-03-04)"
output: pdf_document
editor_options: 
  chunk_output_type: inline
---


  This script aims to 
  
  1. Read the combined EORA indicator data (4 years data in one table), and calculate `net imports` for each indicator, each year, and each country. 
  
  2. Calculate `spillover score` and `spillover index`, according to SDSN's approach. 
  
  
# Set up
```{r Paths and packages, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

### To clear your environment 
remove(list = ls())

### set work dir
path <- rstudioapi::getSourceEditorContext()$path
dir  <- dirname(rstudioapi::getSourceEditorContext()$path); dir
setwd(dir)
setwd('..') # set directory by one folder up
getwd()


### data path
source('./Code/_path of data.R')

### packages
source('./Code/_package list.R')


today <- format(Sys.time(), "%Y%m%d") ## %H%M%S
```



```{r Theme and font}
### plot settings
unit_ns    <- 'cm'
width_1col <- 8.8   ## 1-column
width_2col <- 18    ## 2-column
font       <- 'sans'     ## "TT Arial"
font_size  <- 8          ##  Nature Sustainability: max = 7; min = 5

theme_set(theme_bw(base_size = font_size))

theme_ns <- 
  theme_bw()+
  theme(
    # axis.title =element_blank(),
    # axis.text  =element_blank(),
    # axis.ticks =element_blank(),
    # panel.background = element_rect(fill = NA),
    panel.grid.major.x = element_blank(),
    # panel.grid.major = element_blank(),
    # panel.grid.minor = element_line(colour = "red", size = 1),
    legend.background = element_rect(fill="transparent"),
    legend.key.size = unit(0.15,"cm"),
    text = element_text(size=font_size)
        )
```


## Ancillary data

```{r iso3; shp}
load('./Data/Ancillary_Data_ISO3code_shp.RData') ## iso_eora, pop, gdp, shp, grp, grp_update

### extended country-iso3 pair list for matching
load('./Data/Ancillary_Data_iso_eora_ex.RData')  ## ## iso_eora_ex
```


```{r direction}
### Load cleaned data from Google Sheet --------------------------------------------------
f <- paste0(dirname(dir.eora_cleaned), '/', 'direction.RData')
load(f) ## `direction`, `direction_clean`

##
direction_all <- direction
```


```{r Ancillary data 2 - Eora cleaned format}
### To filter countries only listed in Eora
### - use the Eora data as the template 
temp <- readxl::read_excel(paste0(dir.eora_cleaned, 'CO2.xlsx')) 
temp_eora <- temp %>%
  gather(key = to, value = value, 4:ncol(.)) %>%
  dplyr::select(-value) %>% # -ctr, 
  as.data.frame()
nrow(temp_eora) ## 142884 = 189 * 189 * 4 years

f <- paste0('./Data/data_02_intermediate/dt02_flows/', 'template_eora.RData')
# save(temp_eora, file = f)
load(f)
```





#  Data 

## Get a sense of the MRIO data

  Water use MRIO table as an example
  
```{r eval=FALSE, include=FALSE}
getwd()
xls <- paste0(dir.eora_cleaned, "Water.xlsx")
df <- readxl::read_excel(path = xls)


### total water use for each country ?= row sum in IO table?
### 1. data from IO table
test_rowsum <- df %>% 
  as.data.frame() %>%
  dplyr::mutate(total_ex = rowSums(.[4:ncol(.)])) %>%
  dplyr::select(year, ctr, iso3, total_ex) %>%
  dplyr::mutate(total_ex_10e9 = total_ex/10^9,
                total_ex_10e9 = round(total_ex_10e9, digits = 2)) %>%
  dplyr::filter(year == 2015) %>%
  arrange(ctr)

### 2. data from FAO aquastat 
test_water_fao <- readxl::read_excel(
  path = './Data/data_01_raw/FAO_aquastat/aquastat_Total water withdrawal_fao_2015.xlsx', skip = 1, 
  col_names = c('item', 'ctr', 'year', 'value'))  %>%
  dplyr::filter(!is.na(item), !is.na(ctr)) %>%
  dplyr::mutate(value = round(value, digits = 2)) %>%
  arrange(ctr) %>%
  merge(x = ., y = iso_eora, by.x = 'ctr', by.y = 'Row', all.x = T)%>%
  arrange(!is.na(iso3_eora), iso3_eora)

### 3. compare these two
test_compare <- merge(x = test_rowsum, y = test_water_fao, by.x = 'iso3', by.y = 'iso3_eora', all = T) %>%
  dplyr::select(iso3, total_ex_10e9, value, everything())


### 4. plot
lm_eqn <- function(df){
    m <- lm(y ~ x, df);
    eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
         list(a = format(unname(coef(m)[1]), digits = 2),
              b = format(unname(coef(m)[2]), digits = 2),
             r2 = format(summary(m)$r.squared, digits = 3)))
    as.character(as.expression(eq));
}

test_df <- test_compare %>%
  dplyr::mutate(x = total_ex_10e9, y = value) 

test_df %>%
  ggplot(aes(x = log(total_ex_10e9), y = log(value))) +
  geom_point() +
  geom_smooth() +
  geom_text(x = -2, y = 5, label = lm_eqn(test_df), parse = TRUE)


#### 5. the conclusion: very likely they are the same number, but because of not all of the countries are included in Eora, so the row sum is slightly smaller than data from FAO statistics. 



### max and min
df_l <- df %>% gather(key = 'ctr_col', value = 'value', 4:ncol(.))
max <- max(df_l$value, na.rm = TRUE); max
min <- min(df_l$value, na.rm = TRUE); min

df_l_norm <- df_l %>%
  dplyr::mutate(value_norm = (value - min)/(max - min))



### for 2015
df_l_15 <- df_l %>%
  dplyr::filter(year == 2015)
```






# Analysis

  Here, we use the approach by Sachs et al (SDSN) Reports. That is, looking at the spillovers only, but not the impacts on SDG scores. They took `footprint flows per capita` as the indicator. Here, we use the actual amount of `footprint flows` as the spillover indicator.
  
  **Spillover Score**: the normalized score of each spillover, which measured by "net imports". 
  Scores are interpreted as
    - `100` -- larger negative spillover impact
    - `0`   -- smaller negative spillover impact
    
  **Spillover Index**: a consolidated (or composite) score of multiple spillovers (Sachs et al, 2020) 
    - Sachs et al only measured the Index, but did not report the score by Goal.
    
  Per discussion with Jack Liu, we plan to use *metacoupling impact score*, which is a more inclusive concept that characterize the interactions among not only distant countries and nearby countries. 
    


## Function for calculate "net import" and "normalized score" 
  Normalization function needs to consider which is positive indicator and which is negative indicator. For example, ODA is an example of a positive spillover. 
  
```{r}

### function 1 ----- (not used)
# source('./Code/func_net_import.R')



### function 2 ---------------------------------------------------------------------------
source('./Code/func_net_import_direction.R')


### test code ---
# t <- data.frame(id = seq(1:100), value = sample(x = seq(0,1, 0.05), size = 100, replace = T))
# t[5, 2] <- NA
# t %>% arrange(desc(value)) %>% top_frac(.05)
# b <- t$value %>% unlist() %>% na.omit() 
# length(b) 
# t$value %>% unlist() %>% na.omit() %>% sort(decreasing = T) %>% dplyr::nth(n = length(.)*0.025)

```





## Spillover Score 

### Way 1 ---------> NOT USED

  
 #### 1. Non-SHDB spillover

```{r eval=FALSE, include=FALSE}
xls.ls <- list.files(path = dir.eora_cleaned, pattern = 'xlsx$', full.names = T); xls.ls


### Get the list of files for SHDB data, and remove them from the whole list
xls.ls.SHDB <- str_subset(xls.ls, pattern="SHDB")
xls.ls.other<- setdiff(xls.ls, xls.ls.SHDB); xls.ls.other

cat('There are', xls.ls.SHDB %>% length(),  'SHDB FT indicators') 
cat('There are', xls.ls.other %>% length(), 'Non-SHDB FT indicators') 



### put all spillover indicators in one table
net_imports <- data.frame()

for (xls in xls.ls.other) {
  print(xls)
  df <- readxl::read_excel(path = xls)
  
  ## get the indicator name
  ind <- gsub('.xlsx', '', basename(xls)); print(ind)

  ### check rows and columns
  # print(nrow(df)); print(ncol(df))

  ### max and min
  # df_l <- df %>% gather(key = 'ctr_col', value = 'value', 4:ncol(.))
  # # str(df_l)
  # max <- max(df_l$value, na.rm = TRUE); max
  # min <- min(df_l$value, na.rm = TRUE); min
  
  net_in <- func_net_import(df = df)
  net_imports <- rbind(net_imports, cbind(ind = ind, net_in))

}


### check the data
unique(net_imports$year) %>% sort()
unique(net_imports$ind) %>% sort()
length(unique(net_imports$ind))


net_imports1 <- net_imports
```


   An individual example
```{r eval=FALSE, include=FALSE}

### forest -----
xls <- list.files(path = dir.eora_cleaned, pattern = '^Landuse_forest', full.names = T); xls
df <- readxl::read_excel(path = xls) 

df_flow <- df %>%
  dplyr::filter(year == 2015) %>%
  gather(key = 'Target', value = 'Weight', 4:ncol(.)) %>%
  dplyr::rename(Source = iso3) %>%
  
  ## remove domestic flows -------------------
  dplyr::filter(Source != Target) %>%
  arrange(desc(Weight)) %>%
  
  ## look at the top 10 flows
  head(20) %>%
  as.data.frame()
```


 #### 2. SHDB spillover
```{r eval=FALSE, include=FALSE}
### put all spillover indicators in one table
net_imports <- data.frame()

for (xls in xls.ls.SHDB) {
  # print(xls)
  df <- readxl::read_excel(path = xls) %>%
    dplyr::mutate(year = as.numeric(year)) %>%
    # dplyr::filter(year < 2019) %>%        ### remove years > 2015 in SHDB
    as.data.frame()
  
  ## get the indicator name
  ind <- gsub('.xlsx', '', basename(xls)); print(ind)
  
  net_in <- func_net_import(df = df)
  net_imports <- rbind(net_imports, cbind(ind = ind, net_in))

}


### check the data
names(net_imports)
unique(net_imports$year) %>% sort()
unique(net_imports$ind) %>% sort()
length(unique(net_imports$ind))

net_imports2 <- net_imports
dfSummary(net_imports2)


### 2000, 2014, 2015, 2019 --> 2000, 2005, 2010, 2015 ?
net_imports2_revise <- net_imports2 %>% 
  gather(key = 'vars', value = 'value', total_ex:score) %>%
  spread(key = year, value = value) %>%
  ### we set data in 2000 and 2005 as NA; we use data for 2014 as a substitute of 2010
  dplyr::mutate(`2005` = `2000`, 
                `2010` = `2014`) %>%
  ### then we remove data in 2014 and 2019, and reformat this data to its original format
  dplyr::select(-`2014`, -`2019`) %>%
  gather(key = 'year', value = 'value', 4:ncol(.)) %>%
  spread(key = vars, value = value) %>%
  ### align the column names 
  dplyr::select(names(net_imports1))
  
```


 #### 3. Combine all data

  We may call this net imports data `outsourced footprints`. (OR displaced footprints?)
  
```{r eval=FALSE, include=FALSE}
# id_fig <- 5
# 
# net_imports_fromAll <- rbind(net_imports1, net_imports2_revise, net_imports3, net_imports4, net_imports5) %>%
#   arrange(ind, iso3, year) %>%
#   as.data.frame()
```
  
  



### Way 2 ---------> UPDATE ❗️


#### - direction of impacts
  
  Only indicators with decided *direction* were included in the calculation, while assign *NA* to those with un-decided direction.
  
  - Need to update the `direction` table!
  
```{r }
### get the name list of all the spillovers and manually add `direction` info for further normalizing the values

# xls.ls <- list.files(path = dir.eora_cleaned, pattern = 'xlsx$', full.names = T); xls.ls
# spillover_name_list <- data.frame(ind = gsub('.xlsx', '', basename(xls.ls))) %>%
#   # dplyr::mutate(shdb = str_detect(ind, pattern="SHDB")) %>%
#   dplyr::mutate(direction = '') %>%  ## to determine if it is positive or negative impact
#   as.data.frame()
# writexl::write_xlsx(x = spillover_name_list, path = './Data/data_02_intermediate/dt02_flows/spillover_name_list.xlsx')


### --> manually add `direction`
### ...  
###
### ...


### loop the normalization based on `direction` ---------
# xls <- paste0('./Data/data_02_intermediate/dt02_flows/', "spillover_name_list_directions.xlsx"); xls
# direction <- readxl::read_excel(path = xls) %>%
#   dplyr::filter(!is.na(ind) & !is.na(direction))


```



#### - scale + put all indicators in one table 

  * 8/17/2023 revised `func_net_import_direction()`
    
```{r include=FALSE}
### put all spillover indicators in one table 
net_imports <- data.frame()

for (i in 1:nrow(direction_all)) {
  # print(i)
  ind <- direction_all[i, 'ind']       %>% unlist() %>% paste(sep = '', collapse = ''); 
  drt <- direction_all[i, 'direction'] %>% unlist() %>% paste(sep = '', collapse = '') %>% as.numeric()
  in_out <- direction_all[i, 'Impact_direction'] %>% unlist() %>% paste(sep = '', collapse = '')
  print(ind)
  print(drt)
  print(in_out)
  
  
  ### if the direction is specified, read data; if not, skip. 
  if (!is.na(drt)) {  ## abs(drt) == 1
    xls <- paste0(dir.eora_cleaned, ind, '.xlsx'); #print(xls)
    df  <- readxl::read_excel(path = xls)
  } else {
    cat('\t\t TBD... and skip ------> ', ind, ' <------\n\n\n')
  }
    

  ### check rows and columns
  # print(nrow(df)); print(ncol(df))

  ### max and min
  # df_l <- df %>% gather(key = 'ctr_col', value = 'value', 4:ncol(.))
  # # str(df_l)
  # max <- max(df_l$value, na.rm = TRUE); max
  # min <- min(df_l$value, na.rm = TRUE); min
  
  net_in      <- func_net_import_direction(df = df, in_or_out = in_out, direction_i = drt, frac = 0.025)
  net_imports <- rbind(net_imports, 
                       cbind(ind = ind, net_in))
  
}


net_imports_fromAll <- net_imports
```

  

#### - save final data

```{r include=FALSE}
net_imports_fromAll$scenario <- 'fromAll'

# library(remotes)
# install_github("rapporter/pander") # Strongly recommended
summarytools::dfSummary(net_imports_fromAll)
# skimr::skim(net_imports_fromAll)

length(unique(net_imports_fromAll$iso3))
unique(net_imports_fromAll$year) %>% sort()


###' unify the year list ------------------------------------------------------------------
###' Use the number of years in EORA to determine how many years of data we need to include 
###' in this analysis 
f <- paste0(dir.flowScenario, 'para_n_year_check.RData'); f
load(f) ## `n_year_check` -- how many years of data are included in EORA
n_year_check

if (n_year_check == 4) {
  year_list <- c(2000, 2005, 2010, 2015)
  } else {
  year_list <- c(2015, 2019)
  }
year_list


library(stringr)
net_imports_fromAll <- net_imports_fromAll %>%
  dplyr::filter(year %in% year_list) %>%
  ### use SHDB 2019 for 2015 --------------------!!!
  dplyr::mutate(year = ifelse(
    str_detect(string = ind, pattern = 'SHDB') & year == 2019, 
    2015, year
      )) %>%
  as.data.frame()

## shdb do not have data in 2000, 2005, 2010
net_imports_fromAll_check <- net_imports_fromAll %>%
  dplyr::filter(!year %in% c(2000, 2005, 2010, 2015)) %>%
  dplyr::distinct(ind, year, .keep_all = T)

unique(net_imports_fromAll$ind) %>% sort()

### save the data ------------------------------------------------------------------------
n_ft_ind <- length(unique(net_imports_fromAll$ind)); n_ft_ind
fname <- paste0(dir.flowScenario, 'net_imports_fromAll_', postfix, '_', today,'_', n_ft_ind, '.RData'); fname
save(net_imports_fromAll, file = fname)
```





## Spillover Index

### Index 

```{r - load data}
### load data
ls_f <- list.files(path = dir.flowScenario, pattern = '^net_imports_fromAll_', full.names = T); ls_f
# tail(ls_f, n = 1)
# load(tail(ls_f, n = 1)) ## load the latest data `net_imports_fromAll`


#' the indicator number reduced from 46 to 32, because 14 of which are in fact not used in SDG analysis. 
#' Even we have all the data on 46 ft indicator, we only need to include what are actually used in data analysis. 
```



  Mengyu provides EORA data calculated from consumption-based and production-based accounting approaches. 8/12/2022
  Here, we compared the difference between the two results. 
```{r - compare: pro VS con}
# options(scipen=999) ## disabling scientific notation
options(scipen=0)     ## Scientific notation

### compare
load("./Data/data_02_intermediate/dt02_flows/net_imports_fromAll_20220812con_20220816_45.RData")
net_imp_con <- net_imports_fromAll
load("./Data/data_02_intermediate/dt02_flows/net_imports_fromAll_20220812pro_20230514_45.RData")
net_imp_pro <- net_imports_fromAll


### pick one indicator to compare the difference -----------------------------------------
ind_i <- 'CO2'
# ind_i <- 'Water'
# ind_i <- 'Energytotal'

net_imp_con_i <- net_imp_con %>%
  as.data.frame() %>%
  # format(scientific=T, digits = 5) %>%
  # dplyr::mutate(total_in = total_in*1) %>%
  # dplyr::mutate_if(is.numeric, .funs = funs(as.numeric(as.character(.)))) %>%
  group_by(ind) %>% arrange(desc(net_in)) %>%
  dplyr::filter(ind == ind_i)

net_imp_pro_i <- net_imp_pro %>%
  as.data.frame() %>%
  group_by(ind) %>% arrange(desc(net_in)) %>%
  dplyr::filter(ind == ind_i)
# str(net_imp_con_i)


#### to create a plot function to compare
ggplot_x_y_compare <- function(x, y) {
  ggplot() +
    geom_point(aes(x = x, y = y)) +
    scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x))) +
    scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
            labels = trans_format("log10", math_format(10^.x))) +
    geom_abline(slope = 1) +
    xlab('con-based') + 
    ylab('pro-based') +
    theme_bw() 
}

ggplot_x_y_compare(x = net_imp_con_i$total_ex, y = net_imp_pro_i$total_ex) +
  ggtitle(paste0(ind_i, ' - total exports'))
ggplot_x_y_compare(x = net_imp_con_i$total_in, y = net_imp_pro_i$total_in) +
  ggtitle(paste0(ind_i, ' - total imports'))
ggplot_x_y_compare(x = net_imp_con_i$net_in, y = net_imp_pro_i$net_in) +
  ggtitle(paste0(ind_i, ' - net imports'))
ggplot() + geom_point(aes(x = net_imp_con_i$net_in, y = net_imp_pro_i$net_in)) + 
  ggtitle(paste0(ind_i, ' - net imports')) +
  xlab('con-based') + 
  ylab('pro-based') +
  theme_bw() 



### --------------------------------------------------------------------------------------
# var_rm = 'net_in' ## to remove this variable
var_rm = 'score'  ## to remove this variable


if (var_rm == 'score') {
  var4vs <- 'net_in'
  } else {
  var4vs <- 'score'
  }

net_imp_vs_i <- merge(
  x = net_imp_con_i %>% select(ind:net_in, score), 
  y = net_imp_pro_i %>% select(ind:net_in, score),
  by = c("ind","year","iso3")
) %>%
  dplyr::select(-starts_with(c("total", var_rm))) %>%
  dplyr::rename('con' = paste0(var4vs, '.x'), 
                'pro' = paste0(var4vs, '.y')) %>%
  gather(key = 'source', value = 'value', con:pro) %>%
  as.data.frame()
  


net_imp_vs_i.p <- net_imp_vs_i %>%
  mutate(orderby = ifelse(source=='con', value, -999)) %>%
  ggplot(data = .) +
  geom_col(aes(x = reorder(iso3, orderby), y = value, fill = value>0), show.legend = F) +
  facet_wrap(.~source) +
  coord_flip() +
  xlab(paste0(ind_i, ' - ranked by net imports')) +
  theme_bw() 
net_imp_vs_i.p
fname <- paste0(dir.fig, 'check_conVSpro/compare_netImports_', ind_i, '_', var4vs, '.png'); #fname
ggsave(filename = fname, plot = net_imp_vs_i.p, width = 10, height = 20, units = 'in', dpi = 200)
```


```{r - choose data️️️ ❗}
###
ls_f
f <- subset(x = ls_f, subset = grepl(pattern = postfix, x = ls_f)); f
f <- f[length(f)]; cat('\n we will use this version for final analysis: \n\t', f)
load(f) ## load the latest data `net_imports_fromAll`


### For further analysis, only keep the ft indicators that have direction information 
net_imports_fromAll_use <- net_imports_fromAll %>%
  dplyr::filter(ind %in% c(direction_clean$ind))
```


```{r - Index}

year_list <- c(2000, 2005, 2010, 2015)

### spillover normalized score for each indicator
spillover_norm <- net_imports_fromAll_use %>%
  dplyr::select(ind, iso3, year, score) %>%
  spread(key = 'ind', value = 'score')

unique(spillover_norm$year)
unique(net_imports_fromAll_use$ind)

spillover_norm <- spillover_norm %>% 
  dplyr::select_if(~any(!is.na(.)))

# dfSummary(spillover_norm)


### score for the aggregated index (i.e., the average value of all indicators) ---------------------
spillover_index <- net_imports_fromAll_use %>%
  ungroup() %>% as.data.frame() %>%
  dplyr::filter(year %in% year_list) %>%
  dplyr::select(ind, iso3, year, score) %>%
  group_by(iso3, year) %>%
  dplyr::summarise(index = mean(score, na.rm = T),
                   non_na_count = sum(!is.na(score))) %>%
  ungroup() %>%
  arrange(iso3, year)

hist(spillover_index$index)



### look at social and environmental aspect separately ---------------------------------------------
# spillover_index_se <- net_imports_fromAll_use %>%
#   ungroup() %>% as.data.frame() %>%
#   dplyr::filter(year %in% c(2000, 2005, 2010, 2015)) %>%
#   dplyr::select(ind, iso3, year, score) %>%
#   dplyr::mutate(se = ifelse(str_detect(ind, 'SHDB'), 's', 'e')) %>%
#   group_by(iso3, year, se) %>%
#   dplyr::summarise(index = mean(score, na.rm = T)) %>%
#   arrange(iso3, year)
# 
# hist(spillover_index_se$index)
```




  To visualize each country's TNI impact (spillover impact)
  
  https://www.datanovia.com/en/lessons/heatmap-in-r-static-and-interactive-visualization/
```{r - heat map of each indicator, eval=FALSE, include=FALSE}

### - 1st approach ------------------------------------
data <- spillover_norm %>%
  dplyr::filter(year %in% c(2015)) %>%
  dplyr::select(-year) %>%
  column_to_rownames(var="iso3") %>%
  as.matrix() 

data2 <- t(data)
# Default Heatmap
heatmap(data)
heatmap(data2)



### - 2nd approach ------------------------------------
# library("plotly")  
# plot_ly(data = data, type = "heatmap")  
# 
# ggp <- spillover_norm %>%
#   gather(key = 'ind', value = 'score', 3:ncol(.)) %>%
#   dplyr::select(ind, iso3, year, score) %>%
#   dplyr::filter(year == 2015) %>%
#   ggplot(., aes(y = iso3, x = ind)) + 
#   geom_tile(aes(fill = score))
# ggp      


### - 3rd approach ------------------------------------
library(pheatmap)
f <- paste0(dir.fig, 'spillover score by TNI by country_', postfix, '.png'); f
png(filename = f, width = 25, height = 10, units = 'in', res = 300)
pheatmap::pheatmap(data2, treeheight_row = 0, treeheight_col = 0)
dev.off()


### - 4th approach ------------------------------------
# if (!require("devtools")) install.packages("devtools")
# devtools::install_github("talgalili/d3heatmap")
library("d3heatmap")
d3heatmap((data), colors = "RdYlBu", 
          # dendrogram = 'none', 
          # Rowv = 'none',
          k_row = 4, # Number of groups in rows
          k_col = 1 # Number of groups in columns
          )
detach(package:d3heatmap, unload=TRUE)
```



```{r - check on one ind, eval=FALSE, include=FALSE}
unique(net_imports_fromAll_use$ind)

test <- net_imports_fromAll_use %>%
  dplyr::filter(ind %in% c('CO2', 'Water')) %>%
  dplyr::filter(year %in% c(2015)) %>%
  dplyr::select(1:6) %>%
  dplyr::select(1:3, net_in) %>%
  spread(key = ind, value = net_in) %>%
  as.data.frame()

# SRB ----------------------
#  - CO2: 2nd
#  - Water: 3rd
```




### Map

```{r - Map of TNI Index}
### map of spillover Index score ---------------------------------------------------------
### 
spillover_index_shp <- shp %>%
  dplyr::select(-economy, -income_grp) %>%
  merge(x = ., 
        y = spillover_index, by.x = 'iso_a3', by.y = 'iso3', all.x = T) %>%
  arrange(!is.na(year))
# str(spillover_index_shp)

### to check if all the spillover data has been matched with the shp
spillover_index_shp_match_check <- spillover_index %>%
  dplyr::filter(year == 2015) %>%
  merge(y = shp %>% dplyr::select(-economy, -income_grp), 
        x = ., by.y = 'iso_a3', by.x = 'iso3', all.x = T) 
nrow(spillover_index_shp_match_check) ## ROW was not included here.
```


```{r ... fig2b - map - TNI Index}
## decide color palette 
hist(spillover_index_shp$index)
index_max <- max(spillover_index_shp$index, na.rm = T) %>% ceiling()
index_min <- min(spillover_index_shp$index, na.rm = T) %>% floor()
if (index_min >= 0) {
  palette_map <- "Reds"
  palette_drc <- 1
} else {
  palette_map <- "BrBG"
  palette_drc <- -1
}


### 1 year map for 2015 only -------------------------------------------------------------
map1 <- spillover_index_shp %>%
  dplyr::filter(!is.na(year)) %>%
  dplyr::filter(year == 2015) %>%
  ggplot()+
  geom_sf(aes(fill = index), color='gray80', size = 0.1) +
  scale_fill_distiller(palette = palette_map, direction = palette_drc, na.value = 'black', 
                       name = 'Transnational\nImpact Index') +
  # scale_fill_viridis(direction = -1, option = 'C', discrete = F, name = 'Impact\nIndex') +
  
  scale_y_continuous(expand = c(0, 0)) + ## reduce the space between plot and border
  scale_x_continuous(expand = c(0, 0)) + ## reduce the space between plot and border
  theme_nothing() +
  theme(
    legend.position = c(0.01, 0.01),
    legend.justification = c(0, 0), # right bottom justification
    legend.box.margin = margin(r = 0, b = 0, unit = "mm"), # small margin
    
    axis.text.x=element_blank(), 
    text = element_text(size=font_size),
    panel.grid = element_blank(),
    panel.border = element_blank(),
    # plot.margin = margin(t = 0, r = 0, b = 0, l = -0.1), #unit(c(0,0,0,0), "pt"), ## 0,0,0,0
    axis.ticks.x=element_blank()) 

fig <- ggarrange(map1, labels = "b", font.label = list(size = 12), vjust = 1, hjust = 0); fig
fignm <- paste0('fig2b_map_spillover_index_2015_', postfix, '_', today, '.jpg')
fname <- paste0(dir.fig, '01main/', fignm);
fname
# ggsave(filename = fname, plot = fig, width = width_2col, height = width_2col*2.8/7, units = unit_ns, dpi = 300)

# fname <- paste0(dir.fig, '01main/',    fignm);
# ggsave(filename = fname, plot = fig, width = width_2col, height = width_2col*2.8/7, units = unit_ns, dpi = 300)
```


```{r ... fig2b - tmap - TNI Index}
spillover_index_shp %>%
  dplyr::filter(!is.na(year)) %>%
  dplyr::filter(year == 2015) %>%
  
  tm_shape(.) +
  tm_borders(col = 'gray80', lwd = 0.1) +
  tm_fill(col = "index", title = 'Transnational\nImpact Index', 
          palette = '-BrBG', #midpoint = 0, #n = 7, 
          
          # style = "cont", 
          # breaks = c(index_min, seq(-30, 30, 10), index_max), 
          
          style = "pretty", stretch.palette = T,
          
          # style = "fixed",
          # breaks = c(-Inf, seq(-30, 30, 10), Inf),
          
          legend.reverse = T,
          colorNA = 'black') +
  tm_layout(
    title = 'b', 
    frame = F, attr.outside = F, title.position = c(0, .97), title.size = 1, title.fontface = 'bold',
    # legend.text.size = .5, 
    legend.width = 3,
    legend.title.size = .8,
    legend.text.size = 0.7,
    # panel.label.height = .5,
    outer.margins=0, 
    inner.margins=0, 
    panel.show = F)

f <- gsub('\\.jpg', '_tmap.jpg', fname)
tmap_save(filename = f, width = width_2col, height = width_2col*2.8/7, units = unit_ns, dpi = 300)
```



```{r}
### 4 years map --------------------------------------------------------------------------
# map4 <- spillover_index_shp %>%
#   dplyr::filter(!is.na(year)) %>%
#   ggplot()+
#   geom_sf(aes(fill = index), color='gray80', size = 0.1) +
#   scale_fill_distiller(palette = "Spectral", direction = -1, na.value = 'black', name = 'Impact\nIndex') +
#   # theme(legend.position = c(0.05, 0.3)) +
#   facet_wrap(.~year) +
#   theme(axis.text.x=element_blank(),
#         axis.ticks.x=element_blank(),
#         plot.margin = unit(c(0,0,0,0), "pt"), ## 0,0,0,0
#         )
# # map4
# fname <- paste0(dir.fig, 'spillover/', 'fig_map_spillover_index_4yrs_', today, '.jpg'); fname
# ggsave(filename = fname, plot = map4, width = width_2col, height = width_2col/2, units = unit_ns, dpi = 300)
gc()
```




```{r - Index rank}
### which generate the most impacts and which were most impacted? 
spillover_index_top_bottom <- spillover_index_shp %>%
  st_drop_geometry() %>%
  dplyr::filter(year == 2015) %>%
  arrange(index) %>%
  
  ## remove countries with very few available data ---------------
  dplyr::filter(non_na_count > 5) %>%
  
  ## to get the top 10 and bottom 10 -----------------------------
  dplyr::filter(dense_rank(index) <= 10 | dense_rank(desc(index)) <= 10) %>%
  
  ### choose country group classification
  dplyr::mutate(
    rank = case_when(
      dense_rank(index) <= 10 ~ "Bottom 10", 
      TRUE ~ 'Top 10'),
    group = group_income2,
    group = stringr::str_squish(group),
    group = factor(x = group, levels = c("High income", "Low income"))) %>%
  dplyr::mutate(name = ifelse(iso_a3 == 'USA', 'United States', name)) %>% ## long name to short 
  as.data.frame()
```


  Index rank county-shape [NOT used] 
```{r eval=FALSE, include=FALSE}
spillover_index_top_bottom %>%
  ggplot(aes(x = reorder(name, index))) +
  # geom_hline(yintercept = 50) +
  geom_col(aes(y = index, fill = (rank)), show.legend = T) + 
  # ggnewscale::new_scale("fill") +
  geom_point(aes(y = -2, shape = group), show.legend = T) + # size = 1.2, 
  # scale_fill_manual(name = NULL, values=c('red', 'blue'), labels = c("top 10", "bottom 10"))+
  # scale_shape_manual(values=c(19, 1), labels = c("high income", "low income"))+
  scale_shape_manual(values=c(17, 15, 0, 6))+
  scale_fill_hue(direction = -1) +
  ylab('Transnational Impact Index') +
  coord_flip() +
  theme(axis.title.y=element_blank(), 
        legend.key.size   = unit(.3, 'cm'),  #change legend key size
        legend.key.height = unit(.3, 'cm'),  #change legend key height
        legend.key.width  = unit(.3, 'cm'),  #change legend key width
        legend.text = element_text(size=8),  #change legend text font size
        legend.position = c(0.7, 0.2), legend.margin=unit(0, "cm")) +
  guides(
   shape = guide_legend(order = 2, title = NULL, override.aes = list(fill  = c(NA, NA)), reverse = F),
   fill  = guide_legend(order = 1, title = NULL, override.aes = list(shape = c(NA, NA)), reverse = T)) 

fname <- paste0(dir.fig, 'spillover/', 'spillover_index_top_bottom_shape', today, '.jpg'); fname
ggsave(filename = fname, plot = last_plot(), width = width_1col, height = 8, units = 'cm', dpi = 600)

## https://www.r-bloggers.com/2020/07/controlling-legend-appearance-in-ggplot2-with-override-aes/
```



  Label country group by `color`. 
  - index rank county-color-4-group [NOT used]
  
```{r eval=FALSE, include=FALSE}
spillover_index_top_bottom %>%
  ggplot(aes(x = reorder(name, index))) +
  geom_col(aes(y = index, fill = (rank)), show.legend = T) + 
  geom_point(aes(y = -2, color = group), show.legend = T) + # size = 1.2, 
  scale_fill_manual(values=c('#fee6ce', '#f16913'))+
  scale_color_manual(values=c('#2c7bb6', '#abd9e9', '#fdae61', '#d7191c'))+
  # scale_fill_hue(direction = -1) +
  ylab('Transnational Impact Index') +
  coord_flip() +
  theme(axis.title.y=element_blank(), 
        text = element_text(size = 10),
        legend.key.size   = unit(.3, 'cm'),  #change legend key size
        legend.key.height = unit(.3, 'cm'),  #change legend key height
        legend.key.width  = unit(.3, 'cm'),  #change legend key width
        legend.text = element_text(size=8),  #change legend text font size
        legend.position = c(0.8, 0.2), legend.margin=unit(0, "cm")) +
  guides(
   color = guide_legend(order = 2, title = NULL, override.aes = list(fill  = c(NA, NA)), reverse = F),
   fill  = guide_legend(order = 1, title = NULL, override.aes = list(shape = c(NA, NA)), reverse = T)) 

fname <- paste0(dir.fig, 'spillover/', 'spillover_index_top_bottom_color_', today, '.jpg'); fname
ggsave(filename = fname, plot = last_plot(), width = width_2col/3*2, height = width_2col/2, units = 'cm', dpi = 600)
```


```{r ... fig2a - bar - index rank county-color-2-group}
library(grid) ## linesGrob()

p <- spillover_index_top_bottom %>%
  ggplot(aes(x = reorder(name, index))) +
  geom_col(aes(y = index, fill = (rank)), show.legend = T, alpha = .6) + 
  geom_point(aes(y = min(index)-8, color = group), show.legend = T, size = 3) + # size = 1.2, 
  scale_fill_manual(values=c('#5ab4ac', '#d8b365'))+
  # scale_fill_brewer(palette = "Reds") +
  # scale_fill_manual(values = brewer.pal(n = 5, "Reds")[c(2,4)]) +
  scale_color_manual(values=c('#2371A6', '#F26463'))+
  
  annotation_custom(grob = linesGrob(
    arrow=arrow(type="open", ends="last", length=unit(2,"mm")), 
    gp=gpar(col="#d8b365", lwd=2)), 
    xmin = 0, xmax = 0, ymin = 0, ymax = 40) +
  annotation_custom(grob = grid::textGrob(
    label = "Impacting", hjust=0, 
    gp=gpar(col="#d8b365", cex=.7)),
    xmin = 0, xmax = 0.1, ymin = 10) +
  annotation_custom(grob = linesGrob(
    arrow=arrow(type="open", ends="first", length=unit(2,"mm")), 
    gp=gpar(col="#5ab4ac", lwd=2)), 
    xmin = 0, xmax = 0, ymin = 0, ymax = -25) +
  annotation_custom(grob = grid::textGrob(
    label = "Impacted", hjust=3.6, ## 4
    gp=gpar(col="#5ab4ac", cex=.7)),
    xmin = 0, xmax = 0.1, ymin = -20) +
  
  ggplot2::annotate("text", x = -.5, y = -1, label = "") +
  coord_cartesian(ylim = c(-100, 100), clip = "off") +
  
  ylab('Transnational Impact Index') +
  coord_flip() +
  theme(axis.title.y=element_blank(), 
        text = element_text(size = 10),
        legend.key.size   = unit(.3, 'cm'),  #change legend key size
        legend.key.height = unit(.3, 'cm'),  #change legend key height
        legend.key.width  = unit(.3, 'cm'),  #change legend key width
        legend.text = element_text(size=8),  #change legend text font size
        # legend.margin=unit(0, "cm"),
        legend.margin=margin(0, 0, 0, 0),
        legend.position = c(0.8, 0.2)) +
  guides(
   color = guide_legend(order = 2, title = NULL, override.aes = list(fill  = c(NA, NA)), reverse = F),
   fill  = guide_legend(order = 1, title = NULL, override.aes = list(shape = c(NA, NA)), reverse = T)) 
(
  p2a <- ggarrange(p, labels = "a", font.label = list(size = 12), vjust = 1, hjust = 0)
)
fname <- paste0(dir.fig, '01main/', 'fig2a_spillover_top_bot_color_2grp_', postfix, '_', today,'.jpg'); fname
ggsave(filename = fname, plot = p2a, width = width_2col/3*2, height = width_2col/2, units = 'cm', dpi = 600)
```




  It can be interesting to see the contribution of each spillover to the overall impact. 
  
  *To do*: order the list based on characters or property (social vs. environmental vs. economic vs. security ...)

```{r ... fig ex_4 - Index rank with MC categories}
n_type <- length(unique(net_imports_fromAll_use$ind)); n_type
list20 <- unique(spillover_index_top_bottom$iso_a3); list20

spillover_index_type <- spillover_norm %>%
  dplyr::filter(year %in% c(2015)) %>%
  gather(key = 'indicator', value = 'score', 3:(ncol(.))) %>%
  dplyr::mutate(score_each = score/n_type) %>%
  dplyr::filter(iso3 %in% list20) %>%
  merge(x = ., 
        y = spillover_index_top_bottom %>% dplyr::select(-2, -3, -4, -5), 
        by.x = 'iso3', by.y = 'iso_a3', all.x = T) %>%
  
  ### link with what type of impacts - env, soc, eco, or sec
  merge(x = ., 
        y = direction %>% dplyr::select(ind, SDG_class), 
        by.x = 'indicator', by.y = 'ind', all.x = T) %>%
  as.data.frame() %>%
  dplyr::group_by(iso3, rank, group, SDG_class) %>%
  dplyr::summarise(score_each = sum(score_each, na.rm = T),
                   index = mean(index, na.rm = T))  %>%
  ungroup() %>%
  as.data.frame()
  
str(spillover_index_type)  
unique(spillover_index_type$indicator)
levels(spillover_index_type$SDG_class)
n_class <- unique(spillover_index_type$SDG_class) %>% length()
if(n_class == 3){
  type_levels <- c("Envi", "Soci", "Econ")
  type_labels <- c("Environmental", "Social", "Economic")
  type_colors <- c('#33a02c', '#fdbf6f', '#ff7f00')
} else {
  type_levels <- c("Envi", "Soci", "Econ",  "Secu")
  type_labels <- c("Environmental", "Social", "Economic",  "Security")
  type_colors <- c('#33a02c', '#fdbf6f', '#ff7f00', '#6a3d9a')
}



spillover_index_type_SDGtype <- spillover_index_type %>%
  dplyr::mutate(SDG_class = factor(SDG_class, levels = type_levels, labels = type_labels),
                iso3 = factor(iso3, levels = list20)) ## make sure the order is the same as fig2a
# str(spillover_index_type_SDGtype)


# Stacked
p4ex <- spillover_index_type_SDGtype %>%
  ggplot(data = ., 
         aes(#fill = indicator, 
           fill = fct_rev(SDG_class),
           # x = reorder(iso3, index),
           x = iso3,
           y = score_each)) + 
  scale_fill_manual(values =  type_colors %>% rev(), name = '') +
  geom_bar(position="stack", stat="identity", alpha = 0.8) +
  coord_flip() +
  # geom_hline(yintercept = 0, color = 'red', alpha = .8) +
  theme(
    legend.position = c(0.99, 0.06), ## 0.01
    legend.justification = c(1, 0), 
    legend.box.margin = margin(r = 0, b = 0, unit = "mm"), # small margin
    legend.key.size = unit(0.4,"cm"),
    panel.grid.major.y = element_blank(),
    text = element_text(size = 10),
    legend.margin=margin(0, 0, 0, 0)) +
  
  
  annotation_custom(grob = linesGrob(
    arrow=arrow(type="open", ends="last", length=unit(2,"mm")), 
    gp=gpar(col="#d8b365", lwd=2)), 
    xmin = 0, xmax = 0, ymin = 0, ymax = 40) +
  # annotation_custom(grob = grid::textGrob(
  #   label = "Impacting", hjust=0,
  #   gp=gpar(col="#d8b365", cex=.7)),
  #   xmin = 0, xmax = 0.1, ymin = 10) +
  annotation_custom(grob = linesGrob(
    arrow=arrow(type="open", ends="first", length=unit(2,"mm")),
    gp=gpar(col="#5ab4ac", lwd=2)),
    xmin = 0, xmax = 0, ymin = 0, ymax = -25) +
  # annotation_custom(grob = grid::textGrob(
  #   label = "Impacted", hjust=3,
  #   gp=gpar(col="#5ab4ac", cex=.7)),
  #   xmin = 0, xmax = 0.1, ymin = -20) +
  ggplot2::annotate("text", x = -.5, y = -1, label = "") +
  coord_cartesian(ylim = c(-100, 100), clip = "off") +
  coord_flip() +
  
  
  # xlab('Country') +
  xlab(NULL) +
  ylab('Transnational Impact Index') 
p4ex <- ggarrange(p4ex, labels = "", font.label = list(size = 12), vjust = 1, hjust = 0)
p4ex
fname <- paste0(dir.fig, '01main/', 'ex_4_spillover_index_top_bottom_ByType_', postfix, '_', today, '.jpg'); fname
ggsave(filename = fname, plot = p4ex, width = width_2col/3*2, height = width_2col/2, units = 'cm', dpi = 600)
```



```{r ... fig2a + ex4}
(
  fig2a <- ggarrange(p2a, p4ex, widths = c(0.58, 0.42), align = 'v', font.label = list(size = 12))
 )

fname <- paste0(dir.fig, '01main/', 'fig2a_4ex_combined', '_', today, '.jpg'); fname
ggsave(filename = fname, plot = fig2a, width = width_2col, height = width_2col/2, units = 'cm', dpi = 600)
```


*NOT in use*
```{r - score of SE [X], eval=FALSE, include=FALSE}
spillover_index_se_shp <- shp %>%
  merge(x = ., y = spillover_index_se, by.x = 'iso_a3', by.y = 'iso3', all.x = T) %>%
  arrange(!is.na(year))
# str(score_index_shp)

### to check if all the spillover data has been matched with the shp
spillover_index_se_shp_match_check <- spillover_index_se %>%
  dplyr::filter(year == 2015) %>%
  merge(y = shp, x = ., by.y = 'iso_a3', by.x = 'iso3', all.x = T) 
nrow(spillover_index_se_shp_match_check) ## ROW was not included here. 


map <- spillover_index_se_shp %>%
  dplyr::filter(!is.na(year)) %>%
  ggplot()+
  geom_sf(aes(fill = index), color='gray80', size = 0.1) +
  scale_fill_distiller(palette = "Spectral", direction = 1, na.value = 'black') +
  facet_grid(year~se)
map


spillover_index_se_shp %>%
  dplyr::filter(!is.na(year)) %>%
  dplyr::filter(se == 'e') %>%
  ggplot()+
  geom_sf(aes(fill = index), color='gray80', size = 0.1) +
  scale_fill_distiller(palette = "Spectral", direction = 1, na.value = 'black') +
  facet_grid(year~se)


today <- format(Sys.time(), "%Y%m%d") ## %H%M%S
fname <- paste0(dir.fig, 'spillover/', 'map_spillover_index_se', '_', today, '.jpg'); fname
# ggsave(filename = fname, plot = map, width = width_2col, height = width_2col/2, units = unit_ns, dpi = 300)

```





```{r ... fig ex5 - score map of each impact}

## load ft indicator list and direction data ----------------------
f <- paste0(dirname(dir.eora_cleaned), '/', 'direction_fts.rds'); f
fts <- readRDS(file = f)


## 2. map the selected spillovers --------------------------------
yr <- 2015
spillover_norm_each_shp <-  shp %>%
  merge(x = ., 
        y = spillover_norm, 
        by.x = 'iso_a3', by.y = 'iso3', 
        all.x = T) %>%
  gather(key = 'indicator', value = 'spillover_norm', (ncol(shp)+1):(ncol(.)-1)) %>%
  dplyr::filter(year == yr)


unique(spillover_norm_each_shp$indicator) %>% sort()


### merge and select indicators
map_each <- spillover_norm_each_shp %>%
  # dplyr::filter(year == yr) %>%
  merge(x = ., 
        y = fts, 
        by.x = 'indicator', by.y = 'Filename', all.x = T)

map_each_na <- map_each %>%
  st_drop_geometry() %>%
  dplyr::filter(is.na(ShortName))
unique(map_each_na$indicator) %>% sort()

map_each_ind <- map_each %>%
  st_drop_geometry() %>%
  dplyr::filter(!is.na(ShortName)) %>%
  dplyr::filter(Used == 1) %>%
  dplyr::distinct(ShortName, indicator)

# ind_selected <- map_each_ind$indicator; ind_selected
# ind_name     <- map_each_ind$ShortName; ind_name
n_p <- length(unique(map_each_ind$indicator)); n_p
n_col <- 4
n_row <- ceiling(n_p/n_col + 0.01); n_row 


# map_each <- map_each %>% 
#   dplyr::mutate(spillover_norm_cat = cut_number(spillover_norm, n = 7))


map_each_p <- map_each %>%
  dplyr::filter(!is.na(ShortName)) %>%  ## remove un-matched 
  ggplot()+
  geom_sf(aes(fill = spillover_norm), color='gray80', size = 0.1) +
  scale_fill_distiller(palette = "Spectral", direction = -1, na.value = 'gray70',
                       name= 'Transnational Impact Score') +
  # scale_fill_brewer(palette = "Spectral", direction = -1, na.value = 'gray70', 
  #                   name= 'Transnational Impact Score') +
  facet_wrap(~ShortName, ncol = n_col, nrow = n_row) +
  # ggtitle(yr)+
  theme(legend.position = c(0.9, 0.07)) +
  theme(panel.grid = element_blank(),
        axis.ticks = element_blank(),
        axis.text  = element_blank(),
        legend.key.size = unit(.2, 'cm'), #change legend key size
        plot.title   = element_text(size = 4),
        strip.text.x = element_text(size = 6)
        ) 
# map_each_p
fname <- paste0(dir.fig, '01main/', 'ex_5_map_spillover_norm_each_', yr, '_long_', today, '.jpg'); #fname
ggsave(filename = fname, plot = map_each_p, width = 7, height = n_row*7.2/8, units = 'in', dpi = 300)
```




**THE END** 

  This chuck aims to zoom in to EU region, which is small on the world map. 
  One can ignore this at this stage. 
  
```{r - zoom in map for EU [X], eval=FALSE, include=FALSE}
func_make_polygon <- function(lon_bounds, lat_bounds){
  pts <- c()
  for (j in lat_bounds) {
    for (i in lon_bounds) {
      pt <- c(i, j)
      pts <- rbind(pts, pt)
    }
  }
  print(pts)
  
  ptss <- rbind(pts[1,], pts[3,], pts[4,], pts[2,], pts[1,])
  pol <- st_polygon(list(ptss))
  return(pol)
}

zoom_to <- c(15, 53)  # lon, lat - EU
zoom_level <- 1.8
lon_span <- 180 / 2^zoom_level
lat_span <- 120 / 2^zoom_level
lon_bounds <- c(zoom_to[1] - lon_span / 2, zoom_to[1] + lon_span / 2)
lat_bounds <- c(zoom_to[2] - lat_span / 2, zoom_to[2] + lat_span / 2)

pol <- func_make_polygon(lon_bounds, lat_bounds)
str(pol)
plot(pol)


### crs ? ------------------------------------------------
### ## the units of the CRS are meters (rather than degrees)
crs_lnd <- st_crs(shp); crs_lnd
crs_lnd$epsg
# shp <- st_set_crs(shp, 4326) # set CRS

eu = data.frame(lon = 15, lat = 53) %>% st_as_sf(coords = c("lon", "lat"))
eu_buff_no_crs = st_buffer(eu, dist = 2)
plot(eu_buff_no_crs)

crs_my <- "+proj=longlat +datum=WGS84 +no_defs"   
pol2 <- st_sfc(pol,  crs = crs_my)
plot(pol2)



### plot -------------------------------------------------
map <- map +
  geom_sf(data = st_sfc(pol,  crs = 4326), color = 'black',  fill = NA, size = .2) 
map

map_eu <- map +
  geom_sf(data = st_sfc(st_point(zoom_to), crs = 4326), color = 'transparent', size = 1) +
  coord_sf(xlim = lon_bounds, ylim = lat_bounds) +
  theme_nothing() +
  theme(legend.position = "none",
        panel.border = element_rect(colour = NA, fill=NA, size=.2)) 
# map_eu

p <- ggdraw(map) +
  draw_plot(map_eu, x = -0.05, y = 0.25, width = .3, height = .2) +
  draw_plot_label(
    label = c("", ""),
    hjust = c(0, 0),
    vjust = c(0, 0),
    size = 9
  )
p

```




